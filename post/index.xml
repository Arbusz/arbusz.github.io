<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post on Hugo Zen theme</title>
    <link>https://arbusz.github.io/post/</link>
    <description>Recent content in Post on Hugo Zen theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Tue, 04 Sep 2018 19:25:36 +0800</lastBuildDate>
    <atom:link href="https://arbusz.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>分布式协议 raft</title>
      <link>https://arbusz.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AEraft/</link>
      <pubDate>Tue, 04 Sep 2018 19:25:36 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AEraft/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;协程的概念&#34;&gt;协程的概念&lt;/h2&gt;

&lt;p&gt;对操作系统来说，进程是最小的资源管理单元，线程是最小的执行单元。
对于进程和线程，都是有内核进行调度，有CPU时间片的概念，有多种调度算法。&lt;/p&gt;

&lt;p&gt;协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以有多个协程。
协程不是被操作系统内核所管理，而是完全在用户态执行，换句话说，协程是用户透明的。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。&lt;/p&gt;

&lt;h2 id=&#34;goroutine和协程的区别&#34;&gt;goroutine和协程的区别&lt;/h2&gt;

&lt;p&gt;本质上，goroutine就是协程。不同的是，Go在runtime、系统调用等多方面对goroutine调度进行了封装和处理。当遇到长时间执行或进行系统调用时，会主动把当前的goroutine的CPU转让出去，让其他goroutine能被调度和执行，也就是GO从语言层面支持了协程。&lt;/p&gt;

&lt;p&gt;在内存消耗方面，每个goroutine默认占用的内存远比C、Java的线程少。
在切换调度开销方面，线程涉及到模式切换（用户态与内核态）、多个寄存器刷新。goroutine只有三个寄存器的值修改（PC/SP/DX)。&lt;/p&gt;

&lt;h2 id=&#34;协程的底层实现&#34;&gt;协程的底层实现&lt;/h2&gt;

&lt;p&gt;协程是在应用层模拟线程，他避免了上下文切换的额外消耗，同时兼顾了多线程的优点，简化了高并发程序的复杂性。
实现原理与线程类似，线程a切换到线程b时，需要将线程a的相关执行进度压栈，然后线程b的执行进度出栈，进入线程b的执行序列。协程只不过是在应用层实现了这一点。
协程是基于线程的。内部实现上，维护了一组数据结构和n个线程，真正执行的还是线程。协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步io函数，当这些异步函数返回busy或bloking时，golang利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。
(Go语言运行库封装了异步io，但即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用io事件驱动设计的、按照事物类型划分好合适比例的线程池，在响应时间上，协作调度是硬伤。)&lt;/p&gt;

&lt;p&gt;挖坑：goroutine的详细底层实现和应用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>配置vim用于go开发</title>
      <link>https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sun, 02 Sep 2018 17:10:44 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/</guid>
      <description>&lt;p&gt;
因为服务器没有图形界面，所以项配置一个vim作为go语言开发工具。
服务器是centos，所以以下命令适用于centos系统：&lt;/p&gt;

&lt;h5 id=&#34;首先检查vim是否开启python支持&#34;&gt;首先检查vim是否开启Python支持：&lt;/h5&gt;

&lt;p&gt;运行&lt;code&gt;vim --version |grep python&lt;/code&gt;
如果打印出的Python前面是减号，说明没有加入python支持，后面配置YCM就会报错。所以让我们重新编译vim。
更新源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sduo yum update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级gcc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install centos-release-scl -y
sudo yum install devtoolset-3-toolchain -y
sudo yum install gcc-c++
sudo scl enable devtoolset-3 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装Python开发环境&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sudo yum install python-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级vim&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install ncurses-devel
wget https://github.com/vim/vim/archive/master.zip
unzip master.zip
cd vim-master
cd src/
./configure --with-features=huge -enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config
sudo make
sudo make install
export PATH=/usr/local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;准备工作就绪-可以下载编译ycm了&#34;&gt;准备工作就绪，可以下载编译YCM了&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe

cd ~/.vim/bundle/YouCompleteMe

git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑.vimrc文件，输入一下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin &#39;gmarik/Vundle.vim&#39;
call vundle#end()
filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用vim打开，后输入 :PluginInstall
完成后在 &lt;code&gt;Plugin ‘gmarik/Vundle.vim&lt;/code&gt;的下一行输入 &lt;code&gt;Plugin‘Valloric/YouCompleteMe&lt;/code&gt;，保持后退出。
然后执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/.vim/bundle/YouCompleteMe
./install.py --gocode-completer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要支持C类的补全，用下面的命令。
&lt;code&gt;./install.py --clang-completer&lt;/code&gt;
.vimrc的设置请参考官方文档。&lt;/p&gt;

&lt;h5 id=&#34;然后-安装vim-go插件&#34;&gt;然后，安装vim-go插件&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Plugin &#39;fatih/vim-go&#39;&lt;/code&gt;,然后PluginInstall.
然后安装工具包的依赖
:GoInstallBinaries的执行是交互式的，你需要回车确认。
但是不幸的是，在安装时由于万里长城，一些包下不下来，只好一个一个git clone，然后go install.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim ~/.vim/bundle/vim-go/plugin/go.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到所有依赖包了，接下来就是把所有被墙的包git+go install。&lt;/p&gt;

&lt;h5 id=&#34;vim-go默认是用ultisnips引擎插件-但这个插件需要单独安装&#34;&gt;Vim-go默认是用ultisnips引擎插件，但这个插件需要单独安装。&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;SirVer/ultisnips&#39;
Plugin &#39;honza/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方说这个插件和YCM冲突，所以在.vimrc里面设置一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot; YCM settings
let g:ycm_key_list_select_completion = [&#39;&#39;, &#39;&#39;]
let g:ycm_key_list_previous_completion = [&#39;&#39;]
let g:ycm_key_invoke_completion = &#39;&amp;lt;C-Space&amp;gt;&#39;

&amp;quot; UltiSnips setting
let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;c-b&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;c-z&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样让YCM通过回车和向下的箭头来做list item正向选择，通过向上箭头做反向选择。通过ctrl+space来原地触发补齐提示。&lt;/p&gt;

&lt;p&gt;其他个性化配置详见官方文档。&lt;/p&gt;

&lt;p&gt;Reference:
&amp;gt; &lt;a href=&#34;https://blog.csdn.net/nzyalj/article/details/75331822&#34;&gt;Centos7安装vim8.0 + YouCompleteMe&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://www.cppblog.com/lizao2/archive/2017/05/08/214916.html&#34;&gt;centos安装youcompleteme及简单使用&lt;/a&gt;
&amp;gt; &lt;a href=&#34;https://tonybai.com/2014/11/07/golang-development-environment-for-vim/&#34;&gt;Golang开发环境搭建-Vim篇&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://vimzijun.net/2016/10/30/ultisnip/&#34;&gt;vim 入坑指南（六）插件 UltiSnips&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Raft协议</title>
      <link>https://arbusz.github.io/post/raft%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 02 Sep 2018 17:08:32 +0800</pubDate>
      <guid>https://arbusz.github.io/post/raft%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;p&gt;
分布式存储系统通常采用多个副本进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题，维护多个副本的一致性。
&amp;gt; 一致性是构建容错性的分布式系统的基础。在一个具有一致性的性质的集群里，同一时刻所有的节点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致性。集群具有自动恢复的性质，少数节点失效时不会影响整个集群的正常工作。&lt;/p&gt;

&lt;p&gt;说白了，一致性就是保证即使在部分副本宕机时，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。
&amp;gt;系统中每个节点有三个组件
&amp;gt;- 状态机：当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据
&amp;gt;- log：保存了所有修改记录
&amp;gt;- 一致性模块：一致性模块算法就是用来保证写入的log的命令的一致性，这也是raft算法核心内容&lt;/p&gt;

&lt;p&gt;Raft协议将一致性协议的核心内容分拆成为几个关键阶段，以简化流程，提高协议的可理解性。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;1-leader-election-选主&#34;&gt;1. Leader election（选主）&lt;/h2&gt;

&lt;p&gt;Raft协议的每个副本都会处于三种状态之一：Leader、Follower、Candidate。
&amp;gt;- Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本；
&amp;gt;- Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件
&amp;gt;- Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。&lt;/p&gt;

&lt;p&gt;时间被分为很多连续的随机长度term，term有唯一的Id。每个id一开始就进行选主。
- 1.Follower将自己维护的current_term_id加1
- 2.将自己的状态转为Candidate
- 3.发送RequestVoteRPC消息（附带current_term_id）给其他所有server&lt;/p&gt;

&lt;p&gt;此过程会有三种结果：
- 自己被选为主。当收到majority的投票后，状态切成了Leader，并定期给其他的所有的server发心跳消息（不带log的AppendEntriesRPC）以告诉对方自己是current_term_id所标识的term的Leader。每个term最多有一个leader，term id作为logical lock，在每个RPC消息中都会带上，用于检测过期的消息。当一个server收到的RPC消息中的rpc_term_id比本地的current_term_id更大时，就更新
current_term_id为rpc_term_id，并且如果当前state为Leader或者Candidate时，将自己的状态切为Follower。如果更小，则拒绝这个消息。
- 别人成了主。当Candidate在等待投票的过程中，收到了大于或者等与本地的current_term_id声明对方是Leader的AppendEnteriesRPC时，则将自己的的state切换为Follower，并更新自己本地的current_term_id。
- 没有选出主。没有Leader被选出，每个Candidate等待投票的额过程就已超时，接着Candidates就会将本地的current_term_id再加一，发起RequestVoteRPC进行新一轮的Leader election。&lt;/p&gt;

&lt;p&gt;投票策略：
- 每个节点只会给每个term投一票，具体的是否同意和后续的Safety有关。
- 当投票被瓜分后，所有的Candidate同时超时，然后有可能进入新一轮的票数被瓜分。为了避免这个问题，Raft采用一种很简单的方法：每个Candidate的election timeout从150ms-300ms之间随机取，那么第一个超时的Candidate就可以发起新一轮的leader election，带着最大的term_id给其它所有server发送RequestVoteRPC消息，从而自己成为leader，然后给他们发送心跳消息以告诉他们自己是主。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Raft有2个timeout设置
1）从follow而转换到candidate的timeout： election timeout，设置为：150ms到300ms中的随机数。一个node到达这个timeout之后会发起一个新的选举term（递增的，大的表示新的），向其他节点发起投票请求，包括投给自己的那票，如果获得了大多数选票，那么自己就转换为leader状态
2）node成为leader之后会向其他node发送Append Entries，这个时间为heartbeat timeout
如果lead在实际使用中down掉，剩下的节点会重新开启1）和2）描述的选举流程，保证了高可用性
&lt;em&gt;特殊情况:&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;如果集群中剩下偶数个node-并且在选举的过程中有2个node获得相等的选票数-那么会开启新的一轮term选举-直到有一个node获得多数选票-随机的election-timeout保证可行&#34;&gt;如果集群中剩下偶数个node，并且在选举的过程中有2个node获得相等的选票数，那么会开启新的一轮term选举。直到有一个node获得多数选票（随机的election timeout保证可行）&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-log-replication&#34;&gt;2. Log Replication&lt;/h2&gt;

&lt;p&gt;当Leader被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被replicated state machines执行的命令。leader会把它作为一个log entry append到日志中，然后给其它的server发AppendEntriesRPC请求。当Leader确定一个log entry被safely replicated了（大多数副本已经将该命令写入日志当中），就apply这条log entry到状态机中然后返回结果给客户端。如果某个Follower宕机了或者运行的很慢，或者网络丢包了，则会一直给这个Follower发AppendEntriesRPC直到日志一致。&lt;/p&gt;

&lt;p&gt;当一条日志是commited时，Leader才可以将它应用到状态机中。Raft保证一条commited的log entry已经持久化了并且会被所有的节点执行。&lt;/p&gt;

&lt;h4 id=&#34;如果leader和其他fellower的日志不同怎么办&#34;&gt;如果Leader和其他Fellower的日志不同怎么办&lt;/h4&gt;

&lt;p&gt;我们需要一个机制来保证日志的一致性&lt;/p&gt;

&lt;p&gt;如图中例子，最上面这个是新Leader，a~f是Follower，每个格子代表一条log entry，格子内的数字代表这个log entry是在哪个term上产生的。&lt;/p&gt;

&lt;p&gt;新Leader产生后，就以Leader上的log为准。其它的follower要么少了数据比如b，要么多了数据，比如d，要么既少了又多了数据，比如f。&lt;/p&gt;

&lt;p&gt;因此，需要有一种机制来让leader和follower对log达成一致，leader会为每个follower维护一个nextIndex，表示leader给各个follower发送的下一条log entry在log中的index，初始化为leader的最后一条log entry的下一个位置。leader给follower发送AppendEntriesRPC消息，带着(term_id, (nextIndex-1))， term_id即(nextIndex-1)这个槽位的log entry的term_id，follower接收到AppendEntriesRPC后，会从自己的log中找是不是存在这样的log entry，如果不存在，就给leader回复拒绝消息，然后leader则将nextIndex减1，再重复，知道AppendEntriesRPC消息被接收。&lt;/p&gt;

&lt;p&gt;以leader和b为例：&lt;/p&gt;

&lt;p&gt;初始化，nextIndex为11，leader给b发送AppendEntriesRPC(6,10)，b在自己log的10号槽位中没有找到term_id为6的log entry。则给leader回应一个拒绝消息。接着，leader将nextIndex减一，变成10，然后给b发送AppendEntriesRPC(6, 9)，b在自己log的9号槽位中同样没有找到term_id为6的log entry。循环下去，直到leader发送了AppendEntriesRPC(4,4)，b在自己log的槽位4中找到了term_id为4的log entry。接收了消息。随后，leader就可以从槽位5开始给b推送日志了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4593875-a9ace666b3f34c80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;safety&#34;&gt;Safety&lt;/h3&gt;

&lt;h4 id=&#34;哪些follower有资格成为leader&#34;&gt;哪些follower有资格成为leader?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Raft保证被选为新leader的节点拥有所有已提交的log entry，这与ViewStamped Replication不同，后者不需要这个保证，而是通过其他机制从follower拉取自己没有的提交的日志记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的最后一条日志记录的term_id和index，其他节点收到消息时，如果发现自己的日志比RPC请求中携带的更新，拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。&lt;/p&gt;

&lt;h4 id=&#34;哪些日志记录被认为是commited&#34;&gt;哪些日志记录被认为是commited?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Leader正在replicate当前term（即term 2）的日志记录给其它Follower，一旦Leader确认了这条log entry被majority写盘了，这条log entry就被认为是committed。如图中(a)，S1作为当前term即term2的leader，log index为2的日志被majority写盘了，这条log entry被认为是commited。&lt;/li&gt;
&lt;li&gt;Leader正在replicate更早的term的log entry给其它Follower。图(b)的状态是这么来的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4593875-4be0b2c6ee38dcf4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;example2&#34; /&gt;
这里面隐含一个很严重的问题：一应用到状态机的日志被截断：
1. 在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2。
2. 在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）。
3. S5尚未将日志推送到Followers变离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被commit了（即更新到状态机）。
4. 在阶段d，S1又很不幸地下线了，系统触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 3 &amp;gt; 2, 2. 最新的日志index为2，比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。&lt;/p&gt;

&lt;p&gt;为了避免这种错误，对协议作出修改
&amp;gt;只允许主节点提交包含当前term的日志&lt;/p&gt;

&lt;p&gt;针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被Commit，因为它是来自之前term(2)的日志，直到S1在当前term（4）产生的日志（4， 3）被大多数Follower确认，S1方可Commit（4，3）这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被Commit。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，3）。&lt;/p&gt;

&lt;h4 id=&#34;节点之前的网络状况十分不好-有多个leader怎样处理&#34;&gt;节点之前的网络状况十分不好，有多个leader怎样处理？&lt;/h4&gt;

&lt;p&gt;节点之前的网络状况十分不好，此时会有多个leader，其term也是不同的。
由于commit的修改需要多数通过，那么只有具有最多node的一个集群会commit修改成功。
当网络状况恢复，整个集群的节点会向多数节点的集群同步。这样整个集群中的数据会继续保持一致&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;综述一下Log Replication&lt;/strong&gt;
client给leader发送数据修改请求
leader通过Append Entries在心跳的过程中将修改内容下发到follower nodes
在多数follower 接收了修改内容返回后，leader向client确认
leader向follower发送心跳，具体执行修改操作，此后数据在集群中保持一致&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;3-log-compaction&#34;&gt;3. Log Compaction&lt;/h2&gt;

&lt;p&gt;在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响availability。Raft采用对整个系统进行snapshot来处理，snapshot之前的日志都可以丢弃。Snapshot技术在Chubby和ZooKeeper系统中都有采用。
&amp;gt;Raft用的方案是：每个副本独立的对自己的系统状态进行Snapshot，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot。&lt;/p&gt;

&lt;p&gt;Snapshot中包含以下内容：
- 日志元数据，最后一条commited log entry的 (log index, last_included_term)。这两个值在Snapshot之后的第一条log entry的AppendEntriesRPC的consistency check的时候会被用上。一旦这个server做完了snapshot，就可以把这条记录的最后一条log index及其之前的所有的log entry都删掉。&lt;/p&gt;

&lt;h2 id=&#34;系统状态机-存储系统当前状态&#34;&gt;- 系统状态机：存储系统当前状态&lt;/h2&gt;

&lt;h2 id=&#34;4-membership-changes-待补充&#34;&gt;4. Membership Changes（待补充）&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>两种并发模型</title>
      <link>https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 02 Sep 2018 17:02:35 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;
传统的并发模型主要由两种实现的形式，一是同一个进程下，多个线程天然的共享内存，由程序对读写做同步控制(有锁或无锁).
二是多个进程通过进程间通讯或者内存映射实现数据的同步.&lt;/p&gt;

&lt;h2 id=&#34;actors模型&#34;&gt;Actors模型&lt;/h2&gt;

&lt;p&gt;Actors模型更多的是用消息机制来实现并发，目标是让开发者不再考虑线程这种东西，每个Actor最多同时只能进行一样工作，Actor内部可以有自己的变量和数据.&lt;/p&gt;

&lt;p&gt;在Actors模型中，每个Actor都有一个专属的命名”MailBox”, 其他Actor可以随时选择一个Actor通过邮箱收发数据,对于“MailBox”的维护，通常是使用发布订阅的机制实现的，比如我们可以定义发布者是自己，订阅者可以是某个Socket接口，另外的消息总线或者直接是目标Actor.&lt;/p&gt;

&lt;p&gt;Actors模型避免了由操作系统进行任务调度的问题，在操作系统进程之上，多个Actor可能运行在同一个进程(或线程)中.这就节省了大量的Context切换.&lt;/p&gt;

&lt;h2 id=&#34;csp模型&#34;&gt;CSP模型&lt;/h2&gt;

&lt;p&gt;CSP(Communicating Sequential Process)模型提供一种多个进程公用的“管道(channel)”, 这个channel中存放的是一个个”任务”. CSP中channel是第一类对象(first-class)，它不关注发送消息的实体，而关注与发送消息时使用的channel.&lt;/p&gt;

&lt;p&gt;原始的CSP中channel里的任务都是立即执行的,因为默认情况下的channel是无缓存的, 对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空).反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生.&lt;/p&gt;

&lt;p&gt;除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞.go语言的channel就实现了有缓存和无缓存两种.&lt;/p&gt;

&lt;h2 id=&#34;csp与actors有几个重要的区别&#34;&gt;CSP与Actors有几个重要的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。&lt;/li&gt;
&lt;li&gt;Actor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。&lt;/li&gt;
&lt;li&gt;CSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Actor进程通常是异步的(消息传递给Actor后并不一定马上执行).&lt;/li&gt;
&lt;li&gt;CSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务.&lt;/li&gt;
&lt;li&gt;在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想深入了解可以阅读&lt;a href=&#34;http://jolestar.com/parallel-programming-model-thread-goroutine-actor/&#34;&gt;并发之痛 Thread，Goroutine，Actor
&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个遍历目录的小程序</title>
      <link>https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 05 Jul 2018 08:19:34 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

func main() {
	folder := &amp;quot;.&amp;quot;
	listFile(folder)
}

func listFile(folder string) {
	files, _ := ioutil.ReadDir(folder) //specify the current dir
	for _, file := range files {
		if file.IsDir() {
			listFile(folder + &amp;quot;/&amp;quot; + file.Name())
		} else {
			fmt.Println(folder + &amp;quot;/&amp;quot; + file.Name())
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归打印当前目录下所有文件名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>包含nil指针的接口和nil接口</title>
      <link>https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 04 Jun 2018 21:26:20 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h5 id=&#34;今天看了一段代码-对运行结果十分迷惑-就研究了一番&#34;&gt;今天看了一段代码，对运行结果十分迷惑，就研究了一番。&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)
type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
    var stu *Student
    return stu
}

func main() m{

    if live() == nil {
        fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
    } else {
        fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BBBBBBB &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会出现这样的结果，于是开始调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type People interface {
	Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
	var stu *Student
	return stu
}

func printDynamicType(any interface{}) {
	fmt.Printf(&amp;quot;%T\n&amp;quot;, any)
}

func main() {
	var a = live()
	printDynamicType(a)
	if live() == nil {
		fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
	} else {
		fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
	}

	var s *Student
	fmt.Println(s == nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*main.Student
BBBBBBB &amp;lt;nil&amp;gt;
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来将*Student类型的返回值赋值给People时，接口的类型被赋值为Student类型的指针，而类型描述符被赋值为nil。而一个接口为nil的充要条件为接口的运行时类型为nil，并且接口的运行时值为nil。
如果想运行出现之前以为的运行结果，只需把Show方法和live函数里的变量改成非指针类型即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type People interface {
	Show()
}

type Student struct{}

func (stu Student) Show() {

}

func live() People {
	var stu Student
	return stu
}

func printDynamicType(any interface{}) {
	fmt.Printf(&amp;quot;%T\n&amp;quot;, any)
}

func main() {
	var a = live()
	printDynamicType(a)
	if live() == nil {
		fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
	} else {
		fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.Student
BBBBBBB {}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－函数</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 20 May 2018 19:59:36 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;关键字&lt;code&gt;func&lt;/code&gt;用于定义函数。
- 无须前置声明。
- 不支持命名嵌套类型（nested）。
- 不支持同名参数重载（overload）。
- 不支持默认参数。
- 支持不定长变参。
- 支持多返回值。
- 支持命名返回值。
- 支持命名函数和闭包。
函数属于第一类对象，具备相同签名的函数视作同一类型。
&amp;gt; 第一类对象指可在运行期间创建，可做函数参数或返回值，可存入变量的实体。
函数只能判断是否为nil,不支持其他比较。
从函数返回局部变量指针是安全的，编译器会通过逃逸分析来决定是否在堆上分配内存。&lt;/p&gt;

&lt;p&gt;##参数
函数调用时，必须按照签名顺序传参，以&lt;code&gt;_&lt;/code&gt;命名的参数也不能省略。
在参数列表里，相邻的同类型参数可以合并。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x,y int,s string,_ bool) *int{
	return nil
}

func main(){
	test(1,2,&amp;quot;abc&amp;quot;)//error:not enough arguments in call to test
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;形参是指函数定义中的参数，实参则是函数调用时所传递的参数。形参类似函数局部变量，而实参则是函数外部对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝给形参内存。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x *int) {
	fmt.Printf(&amp;quot;pointer: %p,target: %v\n&amp;quot;, &amp;amp;x, x) //输出形参x的地址
}

func main() {
	a := 100
	p := &amp;amp;a
	fmt.Printf(&amp;quot;pointer: %p,target: %v\n&amp;quot;, &amp;amp;p, p) //输出实参p的地址

	test(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pointer: 0xc04206a018,target: 0xc04204c080
pointer: 0xc04206a028,target: 0xc04204c080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从输出结果来看，尽管形参和实参都指向同一目标，但是指针传递依然被复制。所以可以认为值传递和指针传递都是一种值拷贝传递。
如果函数参数过多，可以将其重构为一个结构体，也算变相实现可选参数和命名的功能。&lt;/p&gt;

&lt;h3 id=&#34;变参&#34;&gt;变参&lt;/h3&gt;

&lt;p&gt;变参本质上是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(s string, a ...int) {
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, a, a)
}

func main() {
	test(&amp;quot;abc&amp;quot;, 1, 2, 3, 4)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]int, [1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切片作为变参时，必须进行展开操作。如果是数组，先将其转换为切片。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(a ...int) {
	fmt.Println(a)
}

func main() {
	a := [3]int{10, 20, 30}//a是数组
	test(a[:]...)//将数组转换为slice后展开
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(a ...int) {
	fmt.Println(a)
}

func main() {
	a := []int{10, 20, 30}//a是切片
	test(a...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为变参是切片，所以参数复制的只是切片自身，并不包括底层数组。&lt;/p&gt;

&lt;h2 id=&#34;返回值&#34;&gt;返回值&lt;/h2&gt;

&lt;p&gt;有返回值的额函数，必须有明确的&lt;code&gt;return&lt;/code&gt;语句，除非有&lt;code&gt;panic&lt;/code&gt;或者是无&lt;code&gt;break&lt;/code&gt;的死循环。
错误写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x int) int {
	if x&amp;gt;0{
		return 1
	} else if x&amp;lt;0{
		return -1
	}
	//error:missing return at the end of function
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x int) int {
	var a int
	if x &amp;gt; 0 {
		a = 1
	} else if x &amp;lt; 0 {
		a = -1
	}
	return a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数支持多返回值，例如常见的&lt;code&gt;error&lt;/code&gt;模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func div(x, y int) (int, error){
	if y==0{
		return 0,errors.New(&amp;quot;division by zero&amp;quot;)
	}	else {
		return x/y,nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命名返回值&#34;&gt;命名返回值&lt;/h3&gt;

&lt;p&gt;命名返回值和命名参数一样，也可以作为局部变量来使用，最后由&lt;code&gt;return&lt;/code&gt;隐式返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func div(x, y int) (z int, err error) {
	if y == 0 {
		err = errors.New(&amp;quot;division by zero&amp;quot;)
	} else {
		z = x / y
		err = nil
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数返回时，需要对所有命名值全部返回。
##匿名函数
匿名函数是没有定义名字符号的函数。
匿名函数可以直接调用，保存到变量，作为参数或返回值。
直接使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	func (s string) {
		println(s)
	} (&amp;quot;hello world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋值给变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	add := func (x, y int) int {
		return x+y
	}
	println(add(1,2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(f func()){
	f()
}

func main(){
	test(func() {
		println(&amp;quot;hello world&amp;quot;)
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() func(int,int) int {
	return func (x,y int) int {
		return x+y
	}
}

func main() {
	add := test()
	println(add(1,2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通函数和匿名函数都可作为结构体字段，或经通道传递。&lt;/p&gt;

&lt;h3 id=&#34;闭包&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;闭包是函数和引用环境的组合体。
闭包直接引用原环境变量。
闭包延迟求值的特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() []func() {
	var s []func()

	for i:=0;i&amp;lt;2;i++{
		s = append(s, func() {
			println(&amp;amp;i,i)
		})
	}
	return s
}

func main(){
	for _,f := range test() {
		f()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xc042040000 2
0xc042040000 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为&lt;code&gt;for&lt;/code&gt;循环复用局部变量&lt;code&gt;i&lt;/code&gt;，每次添加匿名函数时引用的是同一变量。添加操作仅仅是将匿名函数放入列表，并未执行。所以执行的时候读取的是环境变量&lt;code&gt;i&lt;/code&gt;最后一次循环时的值。
解决方法是每次使用不同的环境变量或者传参复制，让各自闭包环境不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() []func() {
	var s []func()

	for i := 0; i &amp;lt; 2; i++ {
		x := i
		s = append(s, func() {
			println(&amp;amp;x, x)
		})
	}
	return s
}

func main() {
	for _, f := range test() {
		f()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xc042008038 0
0xc042008040 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;延迟调用&#34;&gt;延迟调用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;向当前函数注册，等当前函数结束前才被执行。延迟调用常用于资源释放，解除锁定，以及错误处理等操作。
多个&lt;code&gt;defer&lt;/code&gt;按照FILO。
&lt;code&gt;return&lt;/code&gt;和&lt;code&gt;panic&lt;/code&gt;都会终止当前函数，引发&lt;code&gt;defer&lt;/code&gt;。&lt;code&gt;return&lt;/code&gt;执行前会先更新返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() (z int) {
	defer func() {
		println(&amp;quot;defer:&amp;quot;,z)
		z+=100//修改命名返回值
	}()
	return 100//实际执行次序 z=100,call defer return z
}

func main(){
	println(&amp;quot;test:&amp;quot;,test())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;

&lt;p&gt;延迟调用花费代价很大，此过程包括注册、调用等操作，还有额外的缓存开销。所以性能要求高压力大的算法，应避免使用延迟调用。&lt;/p&gt;

&lt;h2 id=&#34;错误处理&#34;&gt;错误处理&lt;/h2&gt;

&lt;h3 id=&#34;error&#34;&gt;error&lt;/h3&gt;

&lt;p&gt;官方推荐做法是返回&lt;code&gt;error&lt;/code&gt;状态。
标准库将&lt;code&gt;error&lt;/code&gt;定义为接口类型，以便实现自定义错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误变量通常以&lt;code&gt;err&lt;/code&gt;作为前缀，且字符串内容全部小写，没有结束标点，以便嵌入到其他格式化字符串中输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var errDivByZero = errors.New(&amp;quot;division by zero&amp;quot;)

func div(x, y int) (int, error) {
	if y == 0 {
		return 0, errDivByZero
	}
	return x / y, nil
}
func main() {
	z, err := div(5, 0)
	if err == errDivByZero {
		log.Fatalln(err)
	}
	println(z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某些时候需要自定义错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DivErr struct {
	x, y int
}

func (DivErr) Error() string {
	return &amp;quot;division by zero&amp;quot;
}

func div(x, y int) (int, error) {
	if y == 0 {
		return 0, DivErr{x, y}
	}
	return x / y, nil
}

func main() {
	z, err := div(5, 0)
	if err != nil {
		switch e := err.(type) {
		case DivErr:
			fmt.Println(e, e.x, e.y)
		default:
			fmt.Println(e)
		}
		log.Fatalln(err)
	}
	println(z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;panic-recover&#34;&gt;panic,recover&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func panic(v interface{})
func recover() interface{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;panic/recover&lt;/code&gt;在使用上更接近&lt;code&gt;try/catch&lt;/code&gt;结构化异常。他们是内置函数而非语句。&lt;code&gt;panic&lt;/code&gt;会立即中断当前 函数流程，执行延迟调用。而在延迟调用中，&lt;code&gt;recover&lt;/code&gt;可捕获并返回&lt;code&gt;panic&lt;/code&gt;提交的错误对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	defer func() {
		if err := recover(); err != nil {//捕获错误
			log.Fatalln(err)
		}
	}()
	panic(&amp;quot;i am dead&amp;quot;)//引发错误
	panic(&amp;quot;exit&amp;quot;)//不会执行
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是否执行&lt;code&gt;recover&lt;/code&gt;，所有延迟调用都会被执行。但是中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() {
	defer println(&amp;quot;test.1&amp;quot;)
	defer println(&amp;quot;test.2&amp;quot;)
	panic(&amp;quot;i am dead&amp;quot;)
}
func main() {
	defer func() {
		log.Println(recover())
	}()
	test()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test.2
test.1
i am dead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连续调用&lt;code&gt;panic&lt;/code&gt;，仅最后一个会被&lt;code&gt;recover&lt;/code&gt;捕获。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	defer func() {
		for {
			if err := recover(); err != nil {
				log.Println(err)
			} else {
				log.Fatalln(&amp;quot;fatal&amp;quot;)
			}
		}
	}()
	defer func() {
		panic(&amp;quot;you are dead&amp;quot;) // 类似重新抛出异常（ rethrow）
	}() // 可先 recover捕获，包装后重新抛出
	panic(&amp;quot;i am dead&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;you are dead
fatal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;recover&lt;/code&gt;必须在延迟调用函数中才执行能正常工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func catch() {
	log.Println(&amp;quot;catch &amp;quot;,recover())
}

func main(){
	defer log.Println(recover())
	defer catch()
	panic(&amp;quot;i am &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;catch i am
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func catch() {
	log.Println(&amp;quot;catch &amp;quot;, recover())
}

func main() {
	defer catch()
	defer log.Println(recover())
	panic(&amp;quot;i am &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nil
catch i am
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－表达式</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 20 May 2018 19:45:45 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;表达式&#34;&gt;表达式&lt;/h1&gt;

&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;

&lt;p&gt;指针运算符为左值时，可以更新目标状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main(){
	x:=10

	var p *int = &amp;amp;x
	println(&amp;amp;x,x)
	println(p,*p)
	*p += 20
	println(p,*p)
	println(&amp;amp;x,x)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0xc04202ff60 10
0xc04202ff60 10
0xc04202ff60 30
0xc04202ff60 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非所有对象都能进行取地址操作
指针类型不能做加减运算和类型转换&lt;/p&gt;

&lt;h2 id=&#34;复合类型变量的初始化&#34;&gt;复合类型变量的初始化&lt;/h2&gt;

&lt;p&gt;一些语法限制
- 初始化表达式必须含类型标签
- 左花括号必须在类型尾部，不能另起一行
- 多个成员的初始值以逗号分开
- 允许多行，但每行必须以逗号或者右花括号结束&lt;/p&gt;

&lt;h2 id=&#34;流控制&#34;&gt;流控制&lt;/h2&gt;

&lt;h5 id=&#34;if-else&#34;&gt;if&amp;hellip;else&amp;hellip;&lt;/h5&gt;

&lt;p&gt;条件表达式必须是布尔类型 ，可以省略括号
可以在条件表达式前加初始化语句，可定义块局部变量（作用域是该&lt;code&gt;if&lt;/code&gt;语句或执行 初始化函数。&lt;/p&gt;

&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;

&lt;p&gt;某条&lt;code&gt;case&lt;/code&gt;语句里有多个条件时，只要有一个命中即可匹配
如果有&lt;code&gt;default&lt;/code&gt;,在全部&lt;code&gt;case&lt;/code&gt;执行失败后才会执行&lt;code&gt;default&lt;/code&gt;语句。
不能重复出现常量&lt;code&gt;case&lt;/code&gt;条件。
相邻的空&lt;code&gt;case&lt;/code&gt;不构成多条件匹配，&lt;code&gt;case&lt;/code&gt;内容为空默认包含一个&lt;code&gt;break&lt;/code&gt;语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; switch x {
 case a:
 case b:
	 println(&amp;quot;b&amp;quot;)
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fallthrough&#34;&gt;fallthrough&lt;/h4&gt;

&lt;p&gt;如需贯通后续的&lt;code&gt;case&lt;/code&gt;,需执行&lt;code&gt;fallthrough。&lt;/code&gt;
当有&lt;code&gt;fallthrough&lt;/code&gt;时，不必匹配后续条件表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	switch x:=5;x{
	default:
		println(x)
	case 5:
		x+=10
		println(x)
		fallthrough
	case 10:
		println(x)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15
15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fallthrough&lt;/code&gt;必须放在&lt;code&gt;case&lt;/code&gt;结尾处，可以使用&lt;code&gt;break&lt;/code&gt;阻止执行。&lt;/p&gt;

&lt;h3 id=&#34;for&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go&lt;/code&gt;语言只有一种循环，但是常见方法都能支持。
常见写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i=0;i&amp;lt;3;i++{ //初始化表达式支持函数调用或者定义局变量
}

for x&amp;lt;10{ //类似“while x&amp;lt;10{}”
}

for { //类似“while true{}”
	break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用&lt;code&gt;for...rang&lt;/code&gt;完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for i,s := range data{
		println(i,s)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许单返回值，或者使用&lt;code&gt;_&lt;/code&gt;忽略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for i := range data{
		println(i)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for _,s := range data{
		println(s)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;code&gt;range&lt;/code&gt;也有个大坑，就是定义的局部变量会重复使用，即一个地址多次写值。
详见本博客博文《go语言坑之for range》。
如果&lt;code&gt;range&lt;/code&gt;的目标表达式是函数优化，也仅被执行一次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	for i,s := range data(){
		println(i,s)
	}

}
func data() []int {
	println(&amp;quot;origin data.&amp;quot;)
	return []int{10,20,30}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin data.
0 10
1 20
2 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goto&lt;/code&gt; &lt;code&gt;continue&lt;/code&gt; &lt;code&gt;break&lt;/code&gt;略过。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－类型</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 27 Mar 2018 19:24:27 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;h4 id=&#34;简短模式&#34;&gt;简短模式：&lt;/h4&gt;

&lt;p&gt;简短模式的限制
- 定义变量，同时显式初始化
- 不能提供数据类型
- 只能用在函数内部&lt;/p&gt;

&lt;p&gt;简短模式也可以是部分退化的赋值操作，即一部分变量定义，一部分只是赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	x := 100
	println(&amp;amp;x)

	x,y := 200, &amp;quot;abc&amp;quot;
	println(x,y)

	y,z := &amp;quot;asd&amp;quot;, 100
	println(y,z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在退化赋值中，靠左变量定义和靠右变量定义都可以.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可以看出，赋值退化的前提条件是，至少有一个新变量被定义，并且必须是同一作用域&lt;/strong&gt;
退化赋值的常用场景是在接受错误类型时，我们可以重复使用err变量&lt;/p&gt;

&lt;h4 id=&#34;多变量赋值&#34;&gt;多变量赋值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
  x,y:= 1,2
  x,y:= y+2, x+3
  println(x,y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;底层过程是先算出所有右值，再进行赋值操作&lt;/p&gt;

&lt;p&gt;####　未使用错误
编译器将未使用的局部变量&lt;/p&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;p&gt;常量必须是编译期可确定的基础数字类型（字符、字符串、数字和布尔值）。
可以在函数代码块中定义常量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	const x  = &amp;quot;abc&amp;quot;
	println(x)

	{
		const x  = 100
		println(x)
		const y  = 1.1
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abc
100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	const (
		x uint16 = 120
		y
		s = &amp;quot;abc&amp;quot;
		z
		p
	)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, y, y)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, z, z)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, p, p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint16, 120
string, abc
string, abc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;枚举&#34;&gt;枚举&lt;/h4&gt;

&lt;p&gt;Go语言没有明确的emun类型，但是可以借助&lt;code&gt;iota&lt;/code&gt;标识符实现一组自增量来实现枚举类型。
&lt;code&gt;iota&lt;/code&gt;的自增作用范围为常量组，可在多常量定义中使用多个&lt;code&gt;iota&lt;/code&gt;。他们单独计数，只需确保组中每行常量个数相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	const (
		_, _ = iota, iota * 10
		a, b
		c, d
		e, f = 10, iota
	)
	fmt.Println(a, b)
	fmt.Println(c, d)
	fmt.Println(e, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 10
2 20
10 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;展开&#34;&gt;展开&lt;/h4&gt;

&lt;p&gt;常量会在编译器预处理阶段直接展开，作为指令使用。数字常量不会分配存储空间，因此无法获取地址。&lt;/p&gt;

&lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;

&lt;h4 id=&#34;别名&#34;&gt;别名&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;byte alias for unit8
rune alias for int32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但相同底层结构一致不一定是别名。&lt;/p&gt;

&lt;p&gt;##　引用类型
特指&lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;这三种预定义类型。
与基本类型相比，它们拥有更复杂的存储结构，除了分配内存以外，还需初始化指针、长度、甚至哈希分布、数据队列等。&lt;/p&gt;

&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;

&lt;p&gt;强制要求显式类型转换。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>协程Coroutines</title>
      <link>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</guid>
      <description>

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;协程的概念&#34;&gt;协程的概念&lt;/h2&gt;

&lt;p&gt;对操作系统来说，进程是最小的资源管理单元，线程是最小的执行单元。
对于进程和线程，都是有内核进行调度，有CPU时间片的概念，有多种调度算法。&lt;/p&gt;

&lt;p&gt;协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以有多个协程。
协程不是被操作系统内核所管理，而是完全在用户态执行，换句话说，协程是用户透明的。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。&lt;/p&gt;

&lt;h2 id=&#34;goroutine和协程的区别&#34;&gt;goroutine和协程的区别&lt;/h2&gt;

&lt;p&gt;本质上，goroutine就是协程。不同的是，Go在runtime、系统调用等多方面对goroutine调度进行了封装和处理。当遇到长时间执行或进行系统调用时，会主动把当前的goroutine的CPU转让出去，让其他goroutine能被调度和执行，也就是GO从语言层面支持了协程。&lt;/p&gt;

&lt;p&gt;在内存消耗方面，每个goroutine默认占用的内存远比C、Java的线程少。
在切换调度开销方面，线程涉及到模式切换（用户态与内核态）、多个寄存器刷新。goroutine只有三个寄存器的值修改（PC/SP/DX)。&lt;/p&gt;

&lt;h2 id=&#34;协程的底层实现&#34;&gt;协程的底层实现&lt;/h2&gt;

&lt;p&gt;协程是在应用层模拟线程，他避免了上下文切换的额外消耗，同时兼顾了多线程的优点，简化了高并发程序的复杂性。
实现原理与线程类似，线程a切换到线程b时，需要将线程a的相关执行进度压栈，然后线程b的执行进度出栈，进入线程b的执行序列。协程只不过是在应用层实现了这一点。
协程是基于线程的。内部实现上，维护了一组数据结构和n个线程，真正执行的还是线程。协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步io函数，当这些异步函数返回busy或bloking时，golang利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。
(Go语言运行库封装了异步io，但即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用io事件驱动设计的、按照事物类型划分好合适比例的线程池，在响应时间上，协作调度是硬伤。)&lt;/p&gt;

&lt;p&gt;挖坑：goroutine的详细底层实现和应用&lt;/p&gt;应用&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

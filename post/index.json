{
    "version" : "https://jsonfeed.org/version/1",
    "title" : "Post on Hugo Zen theme",
    "description": "Recent content in Post on Hugo Zen theme",
    "home_page_url" : "https://arbusz.github.io/",
    "feed_url" : "https://arbusz.github.io/post/index.json",
    "icon" : "https://arbusz.github.io/apple-touch-icon-180.png",
    "favicon" : "https://arbusz.github.io/icon-64.png",
    "author" : {
        "name" : "Arbus",
        "url": "https://example.org/somepage",
        "avatar": "https://arbusz.github.io/path/to/some-image.jpg"
    },
    "items" : [
    {
        "title" : "配置vim用于go开发",
        "date_published" : "2018-09-02T17:10:44+08:00",
        "date_modified" : "2018-09-02T17:10:44+08:00",
        "id" : "https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/",
        "url" : "https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/",
        "content_html" : "\u003cp\u003e\n因为服务器没有图形界面，所以项配置一个vim作为go语言开发工具。\n服务器是centos，所以以下命令适用于centos系统：\u003c/p\u003e\n\n\u003ch5 id=\"首先检查vim是否开启python支持\"\u003e首先检查vim是否开启Python支持：\u003c/h5\u003e\n\n\u003cp\u003e运行\u003ccode\u003evim --version |grep python\u003c/code\u003e\n如果打印出的Python前面是减号，说明没有加入python支持，后面配置YCM就会报错。所以让我们重新编译vim。\n更新源\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esudo yum upgrade\nsduo yum update\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e升级gcc\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esudo yum install centos-release-scl -y\nsudo yum install devtoolset-3-toolchain -y\nsudo yum install gcc-c++\nsudo scl enable devtoolset-3 bash\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e安装Python开发环境\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esudo yum upgrade\nsudo yum install python-devel\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e升级vim\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eyum install ncurses-devel\nwget https://github.com/vim/vim/archive/master.zip\nunzip master.zip\ncd vim-master\ncd src/\n./configure --with-features=huge -enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config\nsudo make\nsudo make install\nexport PATH=/usr/local/bin:$PATH\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"准备工作就绪-可以下载编译ycm了\"\u003e准备工作就绪，可以下载编译YCM了\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003egit clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe\n\ncd ~/.vim/bundle/YouCompleteMe\n\ngit submodule update --init --recursive\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e编辑.vimrc文件，输入一下内容\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eset nocompatible\nfiletype off\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\nPlugin 'gmarik/Vundle.vim'\ncall vundle#end()\nfiletype plugin indent on\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e使用vim打开，后输入 :PluginInstall\n完成后在 \u003ccode\u003ePlugin ‘gmarik/Vundle.vim\u003c/code\u003e的下一行输入 \u003ccode\u003ePlugin‘Valloric/YouCompleteMe\u003c/code\u003e，保持后退出。\n然后执行以下命令\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecd ~/.vim/bundle/YouCompleteMe\n./install.py --gocode-completer\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e如果需要支持C类的补全，用下面的命令。\n\u003ccode\u003e./install.py --clang-completer\u003c/code\u003e\n.vimrc的设置请参考官方文档。\u003c/p\u003e\n\n\u003ch5 id=\"然后-安装vim-go插件\"\u003e然后，安装vim-go插件\u003c/h5\u003e\n\n\u003cp\u003e\u003ccode\u003ePlugin 'fatih/vim-go'\u003c/code\u003e,然后PluginInstall.\n然后安装工具包的依赖\n:GoInstallBinaries的执行是交互式的，你需要回车确认。\n但是不幸的是，在安装时由于万里长城，一些包下不下来，只好一个一个git clone，然后go install.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evim ~/.vim/bundle/vim-go/plugin/go.vim\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e可以看到所有依赖包了，接下来就是把所有被墙的包git+go install。\u003c/p\u003e\n\n\u003ch5 id=\"vim-go默认是用ultisnips引擎插件-但这个插件需要单独安装\"\u003eVim-go默认是用ultisnips引擎插件，但这个插件需要单独安装。\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003ePlugin 'SirVer/ultisnips'\nPlugin 'honza/vim-snippets'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e官方说这个插件和YCM冲突，所以在.vimrc里面设置一下\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026quot; YCM settings\nlet g:ycm_key_list_select_completion = ['', '']\nlet g:ycm_key_list_previous_completion = ['']\nlet g:ycm_key_invoke_completion = '\u0026lt;C-Space\u0026gt;'\n\n\u0026quot; UltiSnips setting\nlet g:UltiSnipsExpandTrigger=\u0026quot;\u0026lt;tab\u0026gt;\u0026quot;\nlet g:UltiSnipsJumpForwardTrigger=\u0026quot;\u0026lt;c-b\u0026gt;\u0026quot;\nlet g:UltiSnipsJumpBackwardTrigger=\u0026quot;\u0026lt;c-z\u0026gt;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e这样让YCM通过回车和向下的箭头来做list item正向选择，通过向上箭头做反向选择。通过ctrl+space来原地触发补齐提示。\u003c/p\u003e\n\n\u003cp\u003e其他个性化配置详见官方文档。\u003c/p\u003e\n\n\u003cp\u003eReference:\n\u0026gt; \u003ca href=\"https://blog.csdn.net/nzyalj/article/details/75331822\"\u003eCentos7安装vim8.0 + YouCompleteMe\u003c/a\u003e\n\u0026gt; \u003ca href=\"http://www.cppblog.com/lizao2/archive/2017/05/08/214916.html\"\u003ecentos安装youcompleteme及简单使用\u003c/a\u003e\n\u0026gt; \u003ca href=\"https://tonybai.com/2014/11/07/golang-development-environment-for-vim/\"\u003eGolang开发环境搭建-Vim篇\u003c/a\u003e\n\u0026gt; \u003ca href=\"http://vimzijun.net/2016/10/30/ultisnip/\"\u003evim 入坑指南（六）插件 UltiSnips\u003c/a\u003e\u003c/p\u003e"
    },
    {
        "title" : "Raft协议",
        "date_published" : "2018-09-02T17:08:32+08:00",
        "date_modified" : "2018-09-02T17:08:32+08:00",
        "id" : "https://arbusz.github.io/post/raft%E5%8D%8F%E8%AE%AE/",
        "url" : "https://arbusz.github.io/post/raft%E5%8D%8F%E8%AE%AE/",
        "content_html" : "\u003cp\u003e\n分布式存储系统通常采用多个副本进行容错，提高系统的可用性。要实现此目标，就必须要解决分布式存储系统的最核心问题，维护多个副本的一致性。\n\u0026gt; 一致性是构建容错性的分布式系统的基础。在一个具有一致性的性质的集群里，同一时刻所有的节点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致性。集群具有自动恢复的性质，少数节点失效时不会影响整个集群的正常工作。\u003c/p\u003e\n\n\u003cp\u003e说白了，一致性就是保证即使在部分副本宕机时，系统仍然能正常对外提供服务。一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state。\n\u0026gt;系统中每个节点有三个组件\n\u0026gt;- 状态机：当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据\n\u0026gt;- log：保存了所有修改记录\n\u0026gt;- 一致性模块：一致性模块算法就是用来保证写入的log的命令的一致性，这也是raft算法核心内容\u003c/p\u003e\n\n\u003cp\u003eRaft协议将一致性协议的核心内容分拆成为几个关键阶段，以简化流程，提高协议的可理解性。\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch2 id=\"1-leader-election-选主\"\u003e1. Leader election（选主）\u003c/h2\u003e\n\n\u003cp\u003eRaft协议的每个副本都会处于三种状态之一：Leader、Follower、Candidate。\n\u0026gt;- Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本；\n\u0026gt;- Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件\n\u0026gt;- Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。\u003c/p\u003e\n\n\u003cp\u003e时间被分为很多连续的随机长度term，term有唯一的Id。每个id一开始就进行选主。\n- 1.Follower将自己维护的current_term_id加1\n- 2.将自己的状态转为Candidate\n- 3.发送RequestVoteRPC消息（附带current_term_id）给其他所有server\u003c/p\u003e\n\n\u003cp\u003e此过程会有三种结果：\n- 自己被选为主。当收到majority的投票后，状态切成了Leader，并定期给其他的所有的server发心跳消息（不带log的AppendEntriesRPC）以告诉对方自己是current_term_id所标识的term的Leader。每个term最多有一个leader，term id作为logical lock，在每个RPC消息中都会带上，用于检测过期的消息。当一个server收到的RPC消息中的rpc_term_id比本地的current_term_id更大时，就更新\ncurrent_term_id为rpc_term_id，并且如果当前state为Leader或者Candidate时，将自己的状态切为Follower。如果更小，则拒绝这个消息。\n- 别人成了主。当Candidate在等待投票的过程中，收到了大于或者等与本地的current_term_id声明对方是Leader的AppendEnteriesRPC时，则将自己的的state切换为Follower，并更新自己本地的current_term_id。\n- 没有选出主。没有Leader被选出，每个Candidate等待投票的额过程就已超时，接着Candidates就会将本地的current_term_id再加一，发起RequestVoteRPC进行新一轮的Leader election。\u003c/p\u003e\n\n\u003cp\u003e投票策略：\n- 每个节点只会给每个term投一票，具体的是否同意和后续的Safety有关。\n- 当投票被瓜分后，所有的Candidate同时超时，然后有可能进入新一轮的票数被瓜分。为了避免这个问题，Raft采用一种很简单的方法：每个Candidate的election timeout从150ms-300ms之间随机取，那么第一个超时的Candidate就可以发起新一轮的leader election，带着最大的term_id给其它所有server发送RequestVoteRPC消息，从而自己成为leader，然后给他们发送心跳消息以告诉他们自己是主。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eRaft有2个timeout设置\n1）从follow而转换到candidate的timeout： election timeout，设置为：150ms到300ms中的随机数。一个node到达这个timeout之后会发起一个新的选举term（递增的，大的表示新的），向其他节点发起投票请求，包括投给自己的那票，如果获得了大多数选票，那么自己就转换为leader状态\n2）node成为leader之后会向其他node发送Append Entries，这个时间为heartbeat timeout\n如果lead在实际使用中down掉，剩下的节点会重新开启1）和2）描述的选举流程，保证了高可用性\n\u003cem\u003e特殊情况:\u003c/em\u003e\u003c/p\u003e\n\n\u003ch2 id=\"如果集群中剩下偶数个node-并且在选举的过程中有2个node获得相等的选票数-那么会开启新的一轮term选举-直到有一个node获得多数选票-随机的election-timeout保证可行\"\u003e如果集群中剩下偶数个node，并且在选举的过程中有2个node获得相等的选票数，那么会开启新的一轮term选举。直到有一个node获得多数选票（随机的election timeout保证可行）\u003c/h2\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"2-log-replication\"\u003e2. Log Replication\u003c/h2\u003e\n\n\u003cp\u003e当Leader被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被replicated state machines执行的命令。leader会把它作为一个log entry append到日志中，然后给其它的server发AppendEntriesRPC请求。当Leader确定一个log entry被safely replicated了（大多数副本已经将该命令写入日志当中），就apply这条log entry到状态机中然后返回结果给客户端。如果某个Follower宕机了或者运行的很慢，或者网络丢包了，则会一直给这个Follower发AppendEntriesRPC直到日志一致。\u003c/p\u003e\n\n\u003cp\u003e当一条日志是commited时，Leader才可以将它应用到状态机中。Raft保证一条commited的log entry已经持久化了并且会被所有的节点执行。\u003c/p\u003e\n\n\u003ch4 id=\"如果leader和其他fellower的日志不同怎么办\"\u003e如果Leader和其他Fellower的日志不同怎么办\u003c/h4\u003e\n\n\u003cp\u003e我们需要一个机制来保证日志的一致性\u003c/p\u003e\n\n\u003cp\u003e如图中例子，最上面这个是新Leader，a~f是Follower，每个格子代表一条log entry，格子内的数字代表这个log entry是在哪个term上产生的。\u003c/p\u003e\n\n\u003cp\u003e新Leader产生后，就以Leader上的log为准。其它的follower要么少了数据比如b，要么多了数据，比如d，要么既少了又多了数据，比如f。\u003c/p\u003e\n\n\u003cp\u003e因此，需要有一种机制来让leader和follower对log达成一致，leader会为每个follower维护一个nextIndex，表示leader给各个follower发送的下一条log entry在log中的index，初始化为leader的最后一条log entry的下一个位置。leader给follower发送AppendEntriesRPC消息，带着(term_id, (nextIndex-1))， term_id即(nextIndex-1)这个槽位的log entry的term_id，follower接收到AppendEntriesRPC后，会从自己的log中找是不是存在这样的log entry，如果不存在，就给leader回复拒绝消息，然后leader则将nextIndex减1，再重复，知道AppendEntriesRPC消息被接收。\u003c/p\u003e\n\n\u003cp\u003e以leader和b为例：\u003c/p\u003e\n\n\u003cp\u003e初始化，nextIndex为11，leader给b发送AppendEntriesRPC(6,10)，b在自己log的10号槽位中没有找到term_id为6的log entry。则给leader回应一个拒绝消息。接着，leader将nextIndex减一，变成10，然后给b发送AppendEntriesRPC(6, 9)，b在自己log的9号槽位中同样没有找到term_id为6的log entry。循环下去，直到leader发送了AppendEntriesRPC(4,4)，b在自己log的槽位4中找到了term_id为4的log entry。接收了消息。随后，leader就可以从槽位5开始给b推送日志了。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"http://upload-images.jianshu.io/upload_images/4593875-a9ace666b3f34c80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"example\" /\u003e\u003c/p\u003e\n\n\u003ch3 id=\"safety\"\u003eSafety\u003c/h3\u003e\n\n\u003ch4 id=\"哪些follower有资格成为leader\"\u003e哪些follower有资格成为leader?\u003c/h4\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eRaft保证被选为新leader的节点拥有所有已提交的log entry，这与ViewStamped Replication不同，后者不需要这个保证，而是通过其他机制从follower拉取自己没有的提交的日志记录\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的最后一条日志记录的term_id和index，其他节点收到消息时，如果发现自己的日志比RPC请求中携带的更新，拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。\u003c/p\u003e\n\n\u003ch4 id=\"哪些日志记录被认为是commited\"\u003e哪些日志记录被认为是commited?\u003c/h4\u003e\n\n\u003col\u003e\n\u003cli\u003eLeader正在replicate当前term（即term 2）的日志记录给其它Follower，一旦Leader确认了这条log entry被majority写盘了，这条log entry就被认为是committed。如图中(a)，S1作为当前term即term2的leader，log index为2的日志被majority写盘了，这条log entry被认为是commited。\u003c/li\u003e\n\u003cli\u003eLeader正在replicate更早的term的log entry给其它Follower。图(b)的状态是这么来的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cimg src=\"http://upload-images.jianshu.io/upload_images/4593875-4be0b2c6ee38dcf4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"example2\" /\u003e\n这里面隐含一个很严重的问题：一应用到状态机的日志被截断：\n1. 在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2。\n2. 在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）。\n3. S5尚未将日志推送到Followers变离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被commit了（即更新到状态机）。\n4. 在阶段d，S1又很不幸地下线了，系统触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 3 \u0026gt; 2, 2. 最新的日志index为2，比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。\u003c/p\u003e\n\n\u003cp\u003e为了避免这种错误，对协议作出修改\n\u0026gt;只允许主节点提交包含当前term的日志\u003c/p\u003e\n\n\u003cp\u003e针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被Commit，因为它是来自之前term(2)的日志，直到S1在当前term（4）产生的日志（4， 3）被大多数Follower确认，S1方可Commit（4，3）这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被Commit。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，3）。\u003c/p\u003e\n\n\u003ch4 id=\"节点之前的网络状况十分不好-有多个leader怎样处理\"\u003e节点之前的网络状况十分不好，有多个leader怎样处理？\u003c/h4\u003e\n\n\u003cp\u003e节点之前的网络状况十分不好，此时会有多个leader，其term也是不同的。\n由于commit的修改需要多数通过，那么只有具有最多node的一个集群会commit修改成功。\n当网络状况恢复，整个集群的节点会向多数节点的集群同步。这样整个集群中的数据会继续保持一致\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e综述一下Log Replication\u003c/strong\u003e\nclient给leader发送数据修改请求\nleader通过Append Entries在心跳的过程中将修改内容下发到follower nodes\n在多数follower 接收了修改内容返回后，leader向client确认\nleader向follower发送心跳，具体执行修改操作，此后数据在集群中保持一致\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch2 id=\"3-log-compaction\"\u003e3. Log Compaction\u003c/h2\u003e\n\n\u003cp\u003e在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响availability。Raft采用对整个系统进行snapshot来处理，snapshot之前的日志都可以丢弃。Snapshot技术在Chubby和ZooKeeper系统中都有采用。\n\u0026gt;Raft用的方案是：每个副本独立的对自己的系统状态进行Snapshot，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot。\u003c/p\u003e\n\n\u003cp\u003eSnapshot中包含以下内容：\n- 日志元数据，最后一条commited log entry的 (log index, last_included_term)。这两个值在Snapshot之后的第一条log entry的AppendEntriesRPC的consistency check的时候会被用上。一旦这个server做完了snapshot，就可以把这条记录的最后一条log index及其之前的所有的log entry都删掉。\u003c/p\u003e\n\n\u003ch2 id=\"系统状态机-存储系统当前状态\"\u003e- 系统状态机：存储系统当前状态\u003c/h2\u003e\n\n\u003ch2 id=\"4-membership-changes-待补充\"\u003e4. Membership Changes（待补充）\u003c/h2\u003e"
    },
    {
        "title" : "两种并发模型",
        "date_published" : "2018-09-02T17:02:35+08:00",
        "date_modified" : "2018-09-02T17:02:35+08:00",
        "id" : "https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/",
        "url" : "https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/",
        "content_html" : "\u003cp\u003e\n传统的并发模型主要由两种实现的形式，一是同一个进程下，多个线程天然的共享内存，由程序对读写做同步控制(有锁或无锁).\n二是多个进程通过进程间通讯或者内存映射实现数据的同步.\u003c/p\u003e\n\n\u003ch2 id=\"actors模型\"\u003eActors模型\u003c/h2\u003e\n\n\u003cp\u003eActors模型更多的是用消息机制来实现并发，目标是让开发者不再考虑线程这种东西，每个Actor最多同时只能进行一样工作，Actor内部可以有自己的变量和数据.\u003c/p\u003e\n\n\u003cp\u003e在Actors模型中，每个Actor都有一个专属的命名”MailBox”, 其他Actor可以随时选择一个Actor通过邮箱收发数据,对于“MailBox”的维护，通常是使用发布订阅的机制实现的，比如我们可以定义发布者是自己，订阅者可以是某个Socket接口，另外的消息总线或者直接是目标Actor.\u003c/p\u003e\n\n\u003cp\u003eActors模型避免了由操作系统进行任务调度的问题，在操作系统进程之上，多个Actor可能运行在同一个进程(或线程)中.这就节省了大量的Context切换.\u003c/p\u003e\n\n\u003ch2 id=\"csp模型\"\u003eCSP模型\u003c/h2\u003e\n\n\u003cp\u003eCSP(Communicating Sequential Process)模型提供一种多个进程公用的“管道(channel)”, 这个channel中存放的是一个个”任务”. CSP中channel是第一类对象(first-class)，它不关注发送消息的实体，而关注与发送消息时使用的channel.\u003c/p\u003e\n\n\u003cp\u003e原始的CSP中channel里的任务都是立即执行的,因为默认情况下的channel是无缓存的, 对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空).反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生.\u003c/p\u003e\n\n\u003cp\u003e除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞.go语言的channel就实现了有缓存和无缓存两种.\u003c/p\u003e\n\n\u003ch2 id=\"csp与actors有几个重要的区别\"\u003eCSP与Actors有几个重要的区别\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。\u003c/li\u003e\n\u003cli\u003eActor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。\u003c/li\u003e\n\u003cli\u003eCSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Actor进程通常是异步的(消息传递给Actor后并不一定马上执行).\u003c/li\u003e\n\u003cli\u003eCSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务.\u003c/li\u003e\n\u003cli\u003e在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e想深入了解可以阅读\u003ca href=\"http://jolestar.com/parallel-programming-model-thread-goroutine-actor/\"\u003e并发之痛 Thread，Goroutine，Actor\n\u003c/a\u003e\u003c/p\u003e"
    },
    {
        "title" : "一个遍历目录的小程序",
        "date_published" : "2018-07-05T08:19:34+08:00",
        "date_modified" : "2018-07-05T08:19:34+08:00",
        "id" : "https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/",
        "url" : "https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/",
        "content_html" : "\u003cp\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;fmt\u0026quot;\n\t\u0026quot;io/ioutil\u0026quot;\n)\n\nfunc main() {\n\tfolder := \u0026quot;.\u0026quot;\n\tlistFile(folder)\n}\n\nfunc listFile(folder string) {\n\tfiles, _ := ioutil.ReadDir(folder) //specify the current dir\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tlistFile(folder + \u0026quot;/\u0026quot; + file.Name())\n\t\t} else {\n\t\t\tfmt.Println(folder + \u0026quot;/\u0026quot; + file.Name())\n\t\t}\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e递归打印当前目录下所有文件名。\u003c/p\u003e"
    },
    {
        "title" : "包含nil指针的接口和nil接口",
        "date_published" : "2018-06-04T21:26:20+08:00",
        "date_modified" : "2018-06-04T21:26:20+08:00",
        "id" : "https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/",
        "url" : "https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/",
        "content_html" : "\u003cp\u003e\u003c/p\u003e\n\n\u003ch5 id=\"今天看了一段代码-对运行结果十分迷惑-就研究了一番\"\u003e今天看了一段代码，对运行结果十分迷惑，就研究了一番。\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n    \u0026quot;fmt\u0026quot;\n)\ntype People interface {\n    Show()\n}\n\ntype Student struct{}\n\nfunc (stu *Student) Show() {\n\n}\n\nfunc live() People {\n    var stu *Student\n    return stu\n}\n\nfunc main() m{\n\n    if live() == nil {\n        fmt.Println(\u0026quot;AAAAAAA\u0026quot;, live())\n    } else {\n        fmt.Println(\u0026quot;BBBBBBB\u0026quot;, live())\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e运行结果如下\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBBBBBBB \u0026lt;nil\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e为什么会出现这样的结果，于是开始调试：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;fmt\u0026quot;\n)\n\ntype People interface {\n\tShow()\n}\n\ntype Student struct{}\n\nfunc (stu *Student) Show() {\n\n}\n\nfunc live() People {\n\tvar stu *Student\n\treturn stu\n}\n\nfunc printDynamicType(any interface{}) {\n\tfmt.Printf(\u0026quot;%T\\n\u0026quot;, any)\n}\n\nfunc main() {\n\tvar a = live()\n\tprintDynamicType(a)\n\tif live() == nil {\n\t\tfmt.Println(\u0026quot;AAAAAAA\u0026quot;, live())\n\t} else {\n\t\tfmt.Println(\u0026quot;BBBBBBB\u0026quot;, live())\n\t}\n\n\tvar s *Student\n\tfmt.Println(s == nil)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e结果是这样的\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e*main.Student\nBBBBBBB \u0026lt;nil\u0026gt;\ntrue\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e原来将*Student类型的返回值赋值给People时，接口的类型被赋值为Student类型的指针，而类型描述符被赋值为nil。而一个接口为nil的充要条件为接口的运行时类型为nil，并且接口的运行时值为nil。\n如果想运行出现之前以为的运行结果，只需把Show方法和live函数里的变量改成非指针类型即可。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;fmt\u0026quot;\n)\n\ntype People interface {\n\tShow()\n}\n\ntype Student struct{}\n\nfunc (stu Student) Show() {\n\n}\n\nfunc live() People {\n\tvar stu Student\n\treturn stu\n}\n\nfunc printDynamicType(any interface{}) {\n\tfmt.Printf(\u0026quot;%T\\n\u0026quot;, any)\n}\n\nfunc main() {\n\tvar a = live()\n\tprintDynamicType(a)\n\tif live() == nil {\n\t\tfmt.Println(\u0026quot;AAAAAAA\u0026quot;, live())\n\t} else {\n\t\tfmt.Println(\u0026quot;BBBBBBB\u0026quot;, live())\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e结果如下：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emain.Student\nBBBBBBB {}\n\u003c/code\u003e\u003c/pre\u003e"
    },
    {
        "title" : "Go语言笔记－函数",
        "date_published" : "2018-05-20T19:59:36+08:00",
        "date_modified" : "2018-05-20T19:59:36+08:00",
        "id" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/",
        "url" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/",
        "content_html" : "\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"函数\"\u003e函数\u003c/h1\u003e\n\n\u003ch2 id=\"定义\"\u003e定义\u003c/h2\u003e\n\n\u003cp\u003e关键字\u003ccode\u003efunc\u003c/code\u003e用于定义函数。\n- 无须前置声明。\n- 不支持命名嵌套类型（nested）。\n- 不支持同名参数重载（overload）。\n- 不支持默认参数。\n- 支持不定长变参。\n- 支持多返回值。\n- 支持命名返回值。\n- 支持命名函数和闭包。\n函数属于第一类对象，具备相同签名的函数视作同一类型。\n\u0026gt; 第一类对象指可在运行期间创建，可做函数参数或返回值，可存入变量的实体。\n函数只能判断是否为nil,不支持其他比较。\n从函数返回局部变量指针是安全的，编译器会通过逃逸分析来决定是否在堆上分配内存。\u003c/p\u003e\n\n\u003cp\u003e##参数\n函数调用时，必须按照签名顺序传参，以\u003ccode\u003e_\u003c/code\u003e命名的参数也不能省略。\n在参数列表里，相邻的同类型参数可以合并。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(x,y int,s string,_ bool) *int{\n\treturn nil\n}\n\nfunc main(){\n\ttest(1,2,\u0026quot;abc\u0026quot;)//error:not enough arguments in call to test\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e形参是指函数定义中的参数，实参则是函数调用时所传递的参数。形参类似函数局部变量，而实参则是函数外部对象。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝给形参内存。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(x *int) {\n\tfmt.Printf(\u0026quot;pointer: %p,target: %v\\n\u0026quot;, \u0026amp;x, x) //输出形参x的地址\n}\n\nfunc main() {\n\ta := 100\n\tp := \u0026amp;a\n\tfmt.Printf(\u0026quot;pointer: %p,target: %v\\n\u0026quot;, \u0026amp;p, p) //输出实参p的地址\n\n\ttest(p)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epointer: 0xc04206a018,target: 0xc04204c080\npointer: 0xc04206a028,target: 0xc04204c080\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e从输出结果来看，尽管形参和实参都指向同一目标，但是指针传递依然被复制。所以可以认为值传递和指针传递都是一种值拷贝传递。\n如果函数参数过多，可以将其重构为一个结构体，也算变相实现可选参数和命名的功能。\u003c/p\u003e\n\n\u003ch3 id=\"变参\"\u003e变参\u003c/h3\u003e\n\n\u003cp\u003e变参本质上是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(s string, a ...int) {\n\tfmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, a, a)\n}\n\nfunc main() {\n\ttest(\u0026quot;abc\u0026quot;, 1, 2, 3, 4)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[]int, [1 2 3 4]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e切片作为变参时，必须进行展开操作。如果是数组，先将其转换为切片。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(a ...int) {\n\tfmt.Println(a)\n}\n\nfunc main() {\n\ta := [3]int{10, 20, 30}//a是数组\n\ttest(a[:]...)//将数组转换为slice后展开\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(a ...int) {\n\tfmt.Println(a)\n}\n\nfunc main() {\n\ta := []int{10, 20, 30}//a是切片\n\ttest(a...)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e因为变参是切片，所以参数复制的只是切片自身，并不包括底层数组。\u003c/p\u003e\n\n\u003ch2 id=\"返回值\"\u003e返回值\u003c/h2\u003e\n\n\u003cp\u003e有返回值的额函数，必须有明确的\u003ccode\u003ereturn\u003c/code\u003e语句，除非有\u003ccode\u003epanic\u003c/code\u003e或者是无\u003ccode\u003ebreak\u003c/code\u003e的死循环。\n错误写法：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(x int) int {\n\tif x\u0026gt;0{\n\t\treturn 1\n\t} else if x\u0026lt;0{\n\t\treturn -1\n\t}\n\t//error:missing return at the end of function\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e正确写法：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(x int) int {\n\tvar a int\n\tif x \u0026gt; 0 {\n\t\ta = 1\n\t} else if x \u0026lt; 0 {\n\t\ta = -1\n\t}\n\treturn a\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e函数支持多返回值，例如常见的\u003ccode\u003eerror\u003c/code\u003e模式：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc div(x, y int) (int, error){\n\tif y==0{\n\t\treturn 0,errors.New(\u0026quot;division by zero\u0026quot;)\n\t}\telse {\n\t\treturn x/y,nil\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"命名返回值\"\u003e命名返回值\u003c/h3\u003e\n\n\u003cp\u003e命名返回值和命名参数一样，也可以作为局部变量来使用，最后由\u003ccode\u003ereturn\u003c/code\u003e隐式返回。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc div(x, y int) (z int, err error) {\n\tif y == 0 {\n\t\terr = errors.New(\u0026quot;division by zero\u0026quot;)\n\t} else {\n\t\tz = x / y\n\t\terr = nil\n\t}\n\treturn\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e参数返回时，需要对所有命名值全部返回。\n##匿名函数\n匿名函数是没有定义名字符号的函数。\n匿名函数可以直接调用，保存到变量，作为参数或返回值。\n直接使用：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main(){\n\tfunc (s string) {\n\t\tprintln(s)\n\t} (\u0026quot;hello world\u0026quot;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e赋值给变量：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main(){\n\tadd := func (x, y int) int {\n\t\treturn x+y\n\t}\n\tprintln(add(1,2))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e作为参数：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test(f func()){\n\tf()\n}\n\nfunc main(){\n\ttest(func() {\n\t\tprintln(\u0026quot;hello world\u0026quot;)\n\t})\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e作为返回值：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test() func(int,int) int {\n\treturn func (x,y int) int {\n\t\treturn x+y\n\t}\n}\n\nfunc main() {\n\tadd := test()\n\tprintln(add(1,2))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e普通函数和匿名函数都可作为结构体字段，或经通道传递。\u003c/p\u003e\n\n\u003ch3 id=\"闭包\"\u003e闭包\u003c/h3\u003e\n\n\u003cp\u003e闭包是函数和引用环境的组合体。\n闭包直接引用原环境变量。\n闭包延迟求值的特性：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test() []func() {\n\tvar s []func()\n\n\tfor i:=0;i\u0026lt;2;i++{\n\t\ts = append(s, func() {\n\t\t\tprintln(\u0026amp;i,i)\n\t\t})\n\t}\n\treturn s\n}\n\nfunc main(){\n\tfor _,f := range test() {\n\t\tf()\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e0xc042040000 2\n0xc042040000 2\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e因为\u003ccode\u003efor\u003c/code\u003e循环复用局部变量\u003ccode\u003ei\u003c/code\u003e，每次添加匿名函数时引用的是同一变量。添加操作仅仅是将匿名函数放入列表，并未执行。所以执行的时候读取的是环境变量\u003ccode\u003ei\u003c/code\u003e最后一次循环时的值。\n解决方法是每次使用不同的环境变量或者传参复制，让各自闭包环境不同。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test() []func() {\n\tvar s []func()\n\n\tfor i := 0; i \u0026lt; 2; i++ {\n\t\tx := i\n\t\ts = append(s, func() {\n\t\t\tprintln(\u0026amp;x, x)\n\t\t})\n\t}\n\treturn s\n}\n\nfunc main() {\n\tfor _, f := range test() {\n\t\tf()\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e0xc042008038 0\n0xc042008040 1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"延迟调用\"\u003e延迟调用\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003edefer\u003c/code\u003e向当前函数注册，等当前函数结束前才被执行。延迟调用常用于资源释放，解除锁定，以及错误处理等操作。\n多个\u003ccode\u003edefer\u003c/code\u003e按照FILO。\n\u003ccode\u003ereturn\u003c/code\u003e和\u003ccode\u003epanic\u003c/code\u003e都会终止当前函数，引发\u003ccode\u003edefer\u003c/code\u003e。\u003ccode\u003ereturn\u003c/code\u003e执行前会先更新返回值。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test() (z int) {\n\tdefer func() {\n\t\tprintln(\u0026quot;defer:\u0026quot;,z)\n\t\tz+=100//修改命名返回值\n\t}()\n\treturn 100//实际执行次序 z=100,call defer return z\n}\n\nfunc main(){\n\tprintln(\u0026quot;test:\u0026quot;,test())\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"性能\"\u003e性能\u003c/h3\u003e\n\n\u003cp\u003e延迟调用花费代价很大，此过程包括注册、调用等操作，还有额外的缓存开销。所以性能要求高压力大的算法，应避免使用延迟调用。\u003c/p\u003e\n\n\u003ch2 id=\"错误处理\"\u003e错误处理\u003c/h2\u003e\n\n\u003ch3 id=\"error\"\u003eerror\u003c/h3\u003e\n\n\u003cp\u003e官方推荐做法是返回\u003ccode\u003eerror\u003c/code\u003e状态。\n标准库将\u003ccode\u003eerror\u003c/code\u003e定义为接口类型，以便实现自定义错误类型。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype error interface {\n\tError() string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e错误变量通常以\u003ccode\u003eerr\u003c/code\u003e作为前缀，且字符串内容全部小写，没有结束标点，以便嵌入到其他格式化字符串中输出。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar errDivByZero = errors.New(\u0026quot;division by zero\u0026quot;)\n\nfunc div(x, y int) (int, error) {\n\tif y == 0 {\n\t\treturn 0, errDivByZero\n\t}\n\treturn x / y, nil\n}\nfunc main() {\n\tz, err := div(5, 0)\n\tif err == errDivByZero {\n\t\tlog.Fatalln(err)\n\t}\n\tprintln(z)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e某些时候需要自定义错误类型。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype DivErr struct {\n\tx, y int\n}\n\nfunc (DivErr) Error() string {\n\treturn \u0026quot;division by zero\u0026quot;\n}\n\nfunc div(x, y int) (int, error) {\n\tif y == 0 {\n\t\treturn 0, DivErr{x, y}\n\t}\n\treturn x / y, nil\n}\n\nfunc main() {\n\tz, err := div(5, 0)\n\tif err != nil {\n\t\tswitch e := err.(type) {\n\t\tcase DivErr:\n\t\t\tfmt.Println(e, e.x, e.y)\n\t\tdefault:\n\t\t\tfmt.Println(e)\n\t\t}\n\t\tlog.Fatalln(err)\n\t}\n\tprintln(z)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"panic-recover\"\u003epanic,recover\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc panic(v interface{})\nfunc recover() interface{}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003epanic/recover\u003c/code\u003e在使用上更接近\u003ccode\u003etry/catch\u003c/code\u003e结构化异常。他们是内置函数而非语句。\u003ccode\u003epanic\u003c/code\u003e会立即中断当前 函数流程，执行延迟调用。而在延迟调用中，\u003ccode\u003erecover\u003c/code\u003e可捕获并返回\u003ccode\u003epanic\u003c/code\u003e提交的错误对象。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {//捕获错误\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}()\n\tpanic(\u0026quot;i am dead\u0026quot;)//引发错误\n\tpanic(\u0026quot;exit\u0026quot;)//不会执行\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e无论是否执行\u003ccode\u003erecover\u003c/code\u003e，所有延迟调用都会被执行。但是中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc test() {\n\tdefer println(\u0026quot;test.1\u0026quot;)\n\tdefer println(\u0026quot;test.2\u0026quot;)\n\tpanic(\u0026quot;i am dead\u0026quot;)\n}\nfunc main() {\n\tdefer func() {\n\t\tlog.Println(recover())\n\t}()\n\ttest()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etest.2\ntest.1\ni am dead\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e连续调用\u003ccode\u003epanic\u003c/code\u003e，仅最后一个会被\u003ccode\u003erecover\u003c/code\u003e捕获。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tdefer func() {\n\t\tfor {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t} else {\n\t\t\t\tlog.Fatalln(\u0026quot;fatal\u0026quot;)\n\t\t\t}\n\t\t}\n\t}()\n\tdefer func() {\n\t\tpanic(\u0026quot;you are dead\u0026quot;) // 类似重新抛出异常（ rethrow）\n\t}() // 可先 recover捕获，包装后重新抛出\n\tpanic(\u0026quot;i am dead\u0026quot;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eyou are dead\nfatal\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003erecover\u003c/code\u003e必须在延迟调用函数中才执行能正常工作。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc catch() {\n\tlog.Println(\u0026quot;catch \u0026quot;,recover())\n}\n\nfunc main(){\n\tdefer log.Println(recover())\n\tdefer catch()\n\tpanic(\u0026quot;i am \u0026quot;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecatch i am\nnil\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc catch() {\n\tlog.Println(\u0026quot;catch \u0026quot;, recover())\n}\n\nfunc main() {\n\tdefer catch()\n\tdefer log.Println(recover())\n\tpanic(\u0026quot;i am \u0026quot;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enil\ncatch i am\n\u003c/code\u003e\u003c/pre\u003e"
    },
    {
        "title" : "Go语言笔记－表达式",
        "date_published" : "2018-05-20T19:45:45+08:00",
        "date_modified" : "2018-05-20T19:45:45+08:00",
        "id" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
        "url" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
        "content_html" : "\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"表达式\"\u003e表达式\u003c/h1\u003e\n\n\u003ch2 id=\"指针\"\u003e指针\u003c/h2\u003e\n\n\u003cp\u003e指针运算符为左值时，可以更新目标状态\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nfunc main(){\n\tx:=10\n\n\tvar p *int = \u0026amp;x\n\tprintln(\u0026amp;x,x)\n\tprintln(p,*p)\n\t*p += 20\n\tprintln(p,*p)\n\tprintln(\u0026amp;x,x)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e0xc04202ff60 10\n0xc04202ff60 10\n0xc04202ff60 30\n0xc04202ff60 30\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e并非所有对象都能进行取地址操作\n指针类型不能做加减运算和类型转换\u003c/p\u003e\n\n\u003ch2 id=\"复合类型变量的初始化\"\u003e复合类型变量的初始化\u003c/h2\u003e\n\n\u003cp\u003e一些语法限制\n- 初始化表达式必须含类型标签\n- 左花括号必须在类型尾部，不能另起一行\n- 多个成员的初始值以逗号分开\n- 允许多行，但每行必须以逗号或者右花括号结束\u003c/p\u003e\n\n\u003ch2 id=\"流控制\"\u003e流控制\u003c/h2\u003e\n\n\u003ch5 id=\"if-else\"\u003eif\u0026hellip;else\u0026hellip;\u003c/h5\u003e\n\n\u003cp\u003e条件表达式必须是布尔类型 ，可以省略括号\n可以在条件表达式前加初始化语句，可定义块局部变量（作用域是该\u003ccode\u003eif\u003c/code\u003e语句或执行 初始化函数。\u003c/p\u003e\n\n\u003ch3 id=\"switch\"\u003eswitch\u003c/h3\u003e\n\n\u003cp\u003e某条\u003ccode\u003ecase\u003c/code\u003e语句里有多个条件时，只要有一个命中即可匹配\n如果有\u003ccode\u003edefault\u003c/code\u003e,在全部\u003ccode\u003ecase\u003c/code\u003e执行失败后才会执行\u003ccode\u003edefault\u003c/code\u003e语句。\n不能重复出现常量\u003ccode\u003ecase\u003c/code\u003e条件。\n相邻的空\u003ccode\u003ecase\u003c/code\u003e不构成多条件匹配，\u003ccode\u003ecase\u003c/code\u003e内容为空默认包含一个\u003ccode\u003ebreak\u003c/code\u003e语句。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e switch x {\n case a:\n case b:\n\t println(\u0026quot;b\u0026quot;)\n }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"fallthrough\"\u003efallthrough\u003c/h4\u003e\n\n\u003cp\u003e如需贯通后续的\u003ccode\u003ecase\u003c/code\u003e,需执行\u003ccode\u003efallthrough。\u003c/code\u003e\n当有\u003ccode\u003efallthrough\u003c/code\u003e时，不必匹配后续条件表达式。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efunc main() {\n\tswitch x:=5;x{\n\tdefault:\n\t\tprintln(x)\n\tcase 5:\n\t\tx+=10\n\t\tprintln(x)\n\t\tfallthrough\n\tcase 10:\n\t\tprintln(x)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e15\n15\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003efallthrough\u003c/code\u003e必须放在\u003ccode\u003ecase\u003c/code\u003e结尾处，可以使用\u003ccode\u003ebreak\u003c/code\u003e阻止执行。\u003c/p\u003e\n\n\u003ch3 id=\"for\"\u003efor\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003ego\u003c/code\u003e语言只有一种循环，但是常见方法都能支持。\n常见写法\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efor i=0;i\u0026lt;3;i++{ //初始化表达式支持函数调用或者定义局变量\n}\n\nfor x\u0026lt;10{ //类似“while x\u0026lt;10{}”\n}\n\nfor { //类似“while true{}”\n\tbreak\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e可用\u003ccode\u003efor...rang\u003c/code\u003e完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tdata := [3]string{\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;}\n\tfor i,s := range data{\n\t\tprintln(i,s)\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e允许单返回值，或者使用\u003ccode\u003e_\u003c/code\u003e忽略。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e func main() {\n\tdata := [3]string{\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;}\n\tfor i := range data{\n\t\tprintln(i)\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tdata := [3]string{\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;}\n\tfor _,s := range data{\n\t\tprintln(s)\n\t}\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e但是\u003ccode\u003erange\u003c/code\u003e也有个大坑，就是定义的局部变量会重复使用，即一个地址多次写值。\n详见本博客博文《go语言坑之for range》。\n如果\u003ccode\u003erange\u003c/code\u003e的目标表达式是函数优化，也仅被执行一次。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tfor i,s := range data(){\n\t\tprintln(i,s)\n\t}\n\n}\nfunc data() []int {\n\tprintln(\u0026quot;origin data.\u0026quot;)\n\treturn []int{10,20,30}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eorigin data.\n0 10\n1 20\n2 30\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003egoto\u003c/code\u003e \u003ccode\u003econtinue\u003c/code\u003e \u003ccode\u003ebreak\u003c/code\u003e略过。\u003c/p\u003e"
    },
    {
        "title" : "Go语言笔记－类型",
        "date_published" : "2018-03-27T19:24:27+08:00",
        "date_modified" : "2018-03-27T19:24:27+08:00",
        "id" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/",
        "url" : "https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/",
        "content_html" : "\u003cp\u003e\u003c/p\u003e\n\n\u003ch1 id=\"类型\"\u003e类型\u003c/h1\u003e\n\n\u003ch2 id=\"变量\"\u003e变量\u003c/h2\u003e\n\n\u003ch4 id=\"简短模式\"\u003e简短模式：\u003c/h4\u003e\n\n\u003cp\u003e简短模式的限制\n- 定义变量，同时显式初始化\n- 不能提供数据类型\n- 只能用在函数内部\u003c/p\u003e\n\n\u003cp\u003e简短模式也可以是部分退化的赋值操作，即一部分变量定义，一部分只是赋值\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tx := 100\n\tprintln(\u0026amp;x)\n\n\tx,y := 200, \u0026quot;abc\u0026quot;\n\tprintln(x,y)\n\n\ty,z := \u0026quot;asd\u0026quot;, 100\n\tprintln(y,z)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e在退化赋值中，靠左变量定义和靠右变量定义都可以.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e可以看出，赋值退化的前提条件是，至少有一个新变量被定义，并且必须是同一作用域\u003c/strong\u003e\n退化赋值的常用场景是在接受错误类型时，我们可以重复使用err变量\u003c/p\u003e\n\n\u003ch4 id=\"多变量赋值\"\u003e多变量赋值\u003c/h4\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main(){\n  x,y:= 1,2\n  x,y:= y+2, x+3\n  println(x,y)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e底层过程是先算出所有右值，再进行赋值操作\u003c/p\u003e\n\n\u003cp\u003e####　未使用错误\n编译器将未使用的局部变量\u003c/p\u003e\n\n\u003ch2 id=\"常量\"\u003e常量\u003c/h2\u003e\n\n\u003cp\u003e常量必须是编译期可确定的基础数字类型（字符、字符串、数字和布尔值）。\n可以在函数代码块中定义常量\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main(){\n\tconst x  = \u0026quot;abc\u0026quot;\n\tprintln(x)\n\n\t{\n\t\tconst x  = 100\n\t\tprintln(x)\n\t\tconst y  = 1.1\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eabc\n100\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值相同\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003eimport \u0026quot;fmt\u0026quot;\n\nfunc main() {\n\tconst (\n\t\tx uint16 = 120\n\t\ty\n\t\ts = \u0026quot;abc\u0026quot;\n\t\tz\n\t\tp\n\t)\n\tfmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, y, y)\n\tfmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, z, z)\n\tfmt.Printf(\u0026quot;%T, %v\\n\u0026quot;, p, p)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003euint16, 120\nstring, abc\nstring, abc\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"枚举\"\u003e枚举\u003c/h4\u003e\n\n\u003cp\u003eGo语言没有明确的emun类型，但是可以借助\u003ccode\u003eiota\u003c/code\u003e标识符实现一组自增量来实现枚举类型。\n\u003ccode\u003eiota\u003c/code\u003e的自增作用范围为常量组，可在多常量定义中使用多个\u003ccode\u003eiota\u003c/code\u003e。他们单独计数，只需确保组中每行常量个数相同。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003eimport \u0026quot;fmt\u0026quot;\n\nfunc main() {\n\tconst (\n\t\t_, _ = iota, iota * 10\n\t\ta, b\n\t\tc, d\n\t\te, f = 10, iota\n\t)\n\tfmt.Println(a, b)\n\tfmt.Println(c, d)\n\tfmt.Println(e, f)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoutput\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1 10\n2 20\n10 3\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"展开\"\u003e展开\u003c/h4\u003e\n\n\u003cp\u003e常量会在编译器预处理阶段直接展开，作为指令使用。数字常量不会分配存储空间，因此无法获取地址。\u003c/p\u003e\n\n\u003ch2 id=\"基本类型\"\u003e基本类型\u003c/h2\u003e\n\n\u003ch4 id=\"别名\"\u003e别名\u003c/h4\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ebyte alias for unit8\nrune alias for int32\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e但相同底层结构一致不一定是别名。\u003c/p\u003e\n\n\u003cp\u003e##　引用类型\n特指\u003ccode\u003eslice\u003c/code\u003e、\u003ccode\u003emap\u003c/code\u003e、\u003ccode\u003echannel\u003c/code\u003e这三种预定义类型。\n与基本类型相比，它们拥有更复杂的存储结构，除了分配内存以外，还需初始化指针、长度、甚至哈希分布、数据队列等。\u003c/p\u003e\n\n\u003ch2 id=\"类型转换\"\u003e类型转换\u003c/h2\u003e\n\n\u003cp\u003e强制要求显式类型转换。\u003c/p\u003e"
    },
    {
        "title" : "协程Coroutines",
        "date_published" : "0001-01-01T00:00:00Z",
        "date_modified" : "0001-01-01T00:00:00Z",
        "id" : "https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/",
        "url" : "https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/",
        "content_html" : "\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003ch2 id=\"协程的概念\"\u003e协程的概念\u003c/h2\u003e\n\n\u003cp\u003e对操作系统来说，进程是最小的资源管理单元，线程是最小的执行单元。\n对于进程和线程，都是有内核进行调度，有CPU时间片的概念，有多种调度算法。\u003c/p\u003e\n\n\u003cp\u003e协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以有多个协程。\n协程不是被操作系统内核所管理，而是完全在用户态执行，换句话说，协程是用户透明的。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\u003c/p\u003e\n\n\u003ch2 id=\"goroutine和协程的区别\"\u003egoroutine和协程的区别\u003c/h2\u003e\n\n\u003cp\u003e本质上，goroutine就是协程。不同的是，Go在runtime、系统调用等多方面对goroutine调度进行了封装和处理。当遇到长时间执行或进行系统调用时，会主动把当前的goroutine的CPU转让出去，让其他goroutine能被调度和执行，也就是GO从语言层面支持了协程。\u003c/p\u003e\n\n\u003cp\u003e在内存消耗方面，每个goroutine默认占用的内存远比C、Java的线程少。\n在切换调度开销方面，线程涉及到模式切换（用户态与内核态）、多个寄存器刷新。goroutine只有三个寄存器的值修改（PC/SP/DX)。\u003c/p\u003e\n\n\u003ch2 id=\"协程的底层实现\"\u003e协程的底层实现\u003c/h2\u003e\n\n\u003cp\u003e协程是在应用层模拟线程，他避免了上下文切换的额外消耗，同时兼顾了多线程的优点，简化了高并发程序的复杂性。\n实现原理与线程类似，线程a切换到线程b时，需要将线程a的相关执行进度压栈，然后线程b的执行进度出栈，进入线程b的执行序列。协程只不过是在应用层实现了这一点。\n协程是基于线程的。内部实现上，维护了一组数据结构和n个线程，真正执行的还是线程。协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步io函数，当这些异步函数返回busy或bloking时，golang利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。\n(Go语言运行库封装了异步io，但即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用io事件驱动设计的、按照事物类型划分好合适比例的线程池，在响应时间上，协作调度是硬伤。)\u003c/p\u003e\n\n\u003cp\u003e挖坑：goroutine的详细底层实现和应用\u003c/p\u003e应用\u003c/p\u003e\n"
    }
    ]
}

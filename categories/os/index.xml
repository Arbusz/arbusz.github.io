<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os on Hugo Zen theme</title>
    <link>https://arbusz.github.io/categories/os/</link>
    <description>Recent content in Os on Hugo Zen theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Sun, 02 Sep 2018 17:02:35 +0800</lastBuildDate>
    <atom:link href="https://arbusz.github.io/categories/os/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>两种并发模型</title>
      <link>https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 02 Sep 2018 17:02:35 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;
传统的并发模型主要由两种实现的形式，一是同一个进程下，多个线程天然的共享内存，由程序对读写做同步控制(有锁或无锁).
二是多个进程通过进程间通讯或者内存映射实现数据的同步.&lt;/p&gt;

&lt;h2 id=&#34;actors模型&#34;&gt;Actors模型&lt;/h2&gt;

&lt;p&gt;Actors模型更多的是用消息机制来实现并发，目标是让开发者不再考虑线程这种东西，每个Actor最多同时只能进行一样工作，Actor内部可以有自己的变量和数据.&lt;/p&gt;

&lt;p&gt;在Actors模型中，每个Actor都有一个专属的命名”MailBox”, 其他Actor可以随时选择一个Actor通过邮箱收发数据,对于“MailBox”的维护，通常是使用发布订阅的机制实现的，比如我们可以定义发布者是自己，订阅者可以是某个Socket接口，另外的消息总线或者直接是目标Actor.&lt;/p&gt;

&lt;p&gt;Actors模型避免了由操作系统进行任务调度的问题，在操作系统进程之上，多个Actor可能运行在同一个进程(或线程)中.这就节省了大量的Context切换.&lt;/p&gt;

&lt;h2 id=&#34;csp模型&#34;&gt;CSP模型&lt;/h2&gt;

&lt;p&gt;CSP(Communicating Sequential Process)模型提供一种多个进程公用的“管道(channel)”, 这个channel中存放的是一个个”任务”. CSP中channel是第一类对象(first-class)，它不关注发送消息的实体，而关注与发送消息时使用的channel.&lt;/p&gt;

&lt;p&gt;原始的CSP中channel里的任务都是立即执行的,因为默认情况下的channel是无缓存的, 对channel的send动作是同步阻塞的，直到另外一个持有该channel引用的执行块取出消息(channel为空).反之，receive动作亦然。藉此，我们可以得到一个基本确定的事实，by default时，实际的receive操作只会在send之后才被发生.&lt;/p&gt;

&lt;p&gt;除此以外，channel还有种Buffered Channel的模式，在默认情况的基础上，你可以确定channel内的消息数量，当channel中消息数量不满足于初始化时Buffer数目时，send动作不会被阻塞，写入操作会立即完成(因此Buffered Channel在很大程度上与Actor非常接近)，直到Buffer数目已满，则send动作开始阻塞.go语言的channel就实现了有缓存和无缓存两种.&lt;/p&gt;

&lt;h2 id=&#34;csp与actors有几个重要的区别&#34;&gt;CSP与Actors有几个重要的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在Actor的设计中，Actor与信箱是耦合的，而在CSP中channel是作为first-class独立存在的。&lt;/li&gt;
&lt;li&gt;Actor中有明确的send/receive的关系，而channel中并不区分这样的关系，执行块可以任意选择发送或者取出消息。&lt;/li&gt;
&lt;li&gt;CSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Actor进程通常是异步的(消息传递给Actor后并不一定马上执行).&lt;/li&gt;
&lt;li&gt;CSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务.&lt;/li&gt;
&lt;li&gt;在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想深入了解可以阅读&lt;a href=&#34;http://jolestar.com/parallel-programming-model-thread-goroutine-actor/&#34;&gt;并发之痛 Thread，Goroutine，Actor
&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>协程Coroutines</title>
      <link>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</guid>
      <description>

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;协程的概念&#34;&gt;协程的概念&lt;/h2&gt;

&lt;p&gt;对操作系统来说，进程是最小的资源管理单元，线程是最小的执行单元。
对于进程和线程，都是有内核进行调度，有CPU时间片的概念，有多种调度算法。&lt;/p&gt;

&lt;p&gt;协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以有多个协程。
协程不是被操作系统内核所管理，而是完全在用户态执行，换句话说，协程是用户透明的。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。&lt;/p&gt;

&lt;h2 id=&#34;goroutine和协程的区别&#34;&gt;goroutine和协程的区别&lt;/h2&gt;

&lt;p&gt;本质上，goroutine就是协程。不同的是，Go在runtime、系统调用等多方面对goroutine调度进行了封装和处理。当遇到长时间执行或进行系统调用时，会主动把当前的goroutine的CPU转让出去，让其他goroutine能被调度和执行，也就是GO从语言层面支持了协程。&lt;/p&gt;

&lt;p&gt;在内存消耗方面，每个goroutine默认占用的内存远比C、Java的线程少。
在切换调度开销方面，线程涉及到模式切换（用户态与内核态）、多个寄存器刷新。goroutine只有三个寄存器的值修改（PC/SP/DX)。&lt;/p&gt;

&lt;h2 id=&#34;协程的底层实现&#34;&gt;协程的底层实现&lt;/h2&gt;

&lt;p&gt;协程是在应用层模拟线程，他避免了上下文切换的额外消耗，同时兼顾了多线程的优点，简化了高并发程序的复杂性。
实现原理与线程类似，线程a切换到线程b时，需要将线程a的相关执行进度压栈，然后线程b的执行进度出栈，进入线程b的执行序列。协程只不过是在应用层实现了这一点。
协程是基于线程的。内部实现上，维护了一组数据结构和n个线程，真正执行的还是线程。协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步io函数，当这些异步函数返回busy或bloking时，golang利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。
(Go语言运行库封装了异步io，但即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用io事件驱动设计的、按照事物类型划分好合适比例的线程池，在响应时间上，协作调度是硬伤。)&lt;/p&gt;

&lt;p&gt;挖坑：goroutine的详细底层实现和应用&lt;/p&gt;应用&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Hugo Zen theme</title>
    <link>https://arbusz.github.io/categories/golang/</link>
    <description>Recent content in Golang on Hugo Zen theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Sun, 02 Sep 2018 17:10:44 +0800</lastBuildDate>
    <atom:link href="https://arbusz.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Vim的go语言配置</title>
      <link>https://arbusz.github.io/post/vim%E7%9A%84go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 02 Sep 2018 17:10:44 +0800</pubDate>
      <guid>https://arbusz.github.io/post/vim%E7%9A%84go%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;因为服务器没有图形界面，所以项配置一个vim作为go语言开发工具。
服务器是centos，所以以下命令适用于centos系统：&lt;/p&gt;

&lt;h5 id=&#34;首先检查vim是否开启python支持&#34;&gt;首先检查vim是否开启Python支持：&lt;/h5&gt;

&lt;p&gt;运行&lt;code&gt;vim --version |grep python&lt;/code&gt;
如果打印出的Python前面是减号，说明没有加入python支持，后面配置YCM就会报错。所以让我们重新编译vim。
更新源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sduo yum update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级gcc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install centos-release-scl -y
sudo yum install devtoolset-3-toolchain -y
sudo yum install gcc-c++
sudo scl enable devtoolset-3 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装Python开发环境&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sudo yum install python-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级vim&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install ncurses-devel
wget https://github.com/vim/vim/archive/master.zip
unzip master.zip
cd vim-master
cd src/
./configure --with-features=huge -enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config
sudo make
sudo make install
export PATH=/usr/local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;准备工作就绪-可以下载编译ycm了&#34;&gt;准备工作就绪，可以下载编译YCM了&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe

cd ~/.vim/bundle/YouCompleteMe

git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑.vimrc文件，输入一下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin &#39;gmarik/Vundle.vim&#39;
call vundle#end()
filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用vim打开，后输入 :PluginInstall
完成后在 &lt;code&gt;Plugin ‘gmarik/Vundle.vim&lt;/code&gt;的下一行输入 &lt;code&gt;Plugin‘Valloric/YouCompleteMe&lt;/code&gt;，保持后退出。
然后执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/.vim/bundle/YouCompleteMe
./install.py --gocode-completer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要支持C类的补全，用下面的命令。
&lt;code&gt;./install.py --clang-completer&lt;/code&gt;
.vimrc的设置请参考官方文档。&lt;/p&gt;

&lt;h5 id=&#34;然后-安装vim-go插件&#34;&gt;然后，安装vim-go插件&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Plugin &#39;fatih/vim-go&#39;&lt;/code&gt;,然后PluginInstall.
然后安装工具包的依赖
:GoInstallBinaries的执行是交互式的，你需要回车确认。
但是不幸的是，在安装时由于万里长城，一些包下不下来，只好一个一个git clone，然后go install.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim ~/.vim/bundle/vim-go/plugin/go.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到所有依赖包了，接下来就是把所有被墙的包git+go install。&lt;/p&gt;

&lt;h5 id=&#34;vim-go默认是用ultisnips引擎插件-但这个插件需要单独安装&#34;&gt;Vim-go默认是用ultisnips引擎插件，但这个插件需要单独安装。&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;SirVer/ultisnips&#39;
Plugin &#39;honza/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方说这个插件和YCM冲突，所以在.vimrc里面设置一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot; YCM settings
let g:ycm_key_list_select_completion = [&#39;&#39;, &#39;&#39;]
let g:ycm_key_list_previous_completion = [&#39;&#39;]
let g:ycm_key_invoke_completion = &#39;&amp;lt;C-Space&amp;gt;&#39;

&amp;quot; UltiSnips setting
let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;c-b&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;c-z&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样让YCM通过回车和向下的箭头来做list item正向选择，通过向上箭头做反向选择。通过ctrl+space来原地触发补齐提示。&lt;/p&gt;

&lt;p&gt;其他个性化配置详见官方文档。&lt;/p&gt;

&lt;p&gt;Reference:
&amp;gt; &lt;a href=&#34;https://blog.csdn.net/nzyalj/article/details/75331822&#34;&gt;Centos7安装vim8.0 + YouCompleteMe&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://www.cppblog.com/lizao2/archive/2017/05/08/214916.html&#34;&gt;centos安装youcompleteme及简单使用&lt;/a&gt;
&amp;gt; &lt;a href=&#34;https://tonybai.com/2014/11/07/golang-development-environment-for-vim/&#34;&gt;Golang开发环境搭建-Vim篇&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://vimzijun.net/2016/10/30/ultisnip/&#34;&gt;vim 入坑指南（六）插件 UltiSnips&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>配置vim用于go开发</title>
      <link>https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sun, 02 Sep 2018 17:10:44 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E9%85%8D%E7%BD%AEvim%E7%94%A8%E4%BA%8Ego%E5%BC%80%E5%8F%91/</guid>
      <description>&lt;p&gt;
因为服务器没有图形界面，所以项配置一个vim作为go语言开发工具。
服务器是centos，所以以下命令适用于centos系统：&lt;/p&gt;

&lt;h5 id=&#34;首先检查vim是否开启python支持&#34;&gt;首先检查vim是否开启Python支持：&lt;/h5&gt;

&lt;p&gt;运行&lt;code&gt;vim --version |grep python&lt;/code&gt;
如果打印出的Python前面是减号，说明没有加入python支持，后面配置YCM就会报错。所以让我们重新编译vim。
更新源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sduo yum update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级gcc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install centos-release-scl -y
sudo yum install devtoolset-3-toolchain -y
sudo yum install gcc-c++
sudo scl enable devtoolset-3 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装Python开发环境&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum upgrade
sudo yum install python-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级vim&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install ncurses-devel
wget https://github.com/vim/vim/archive/master.zip
unzip master.zip
cd vim-master
cd src/
./configure --with-features=huge -enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config
sudo make
sudo make install
export PATH=/usr/local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;准备工作就绪-可以下载编译ycm了&#34;&gt;准备工作就绪，可以下载编译YCM了&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe

cd ~/.vim/bundle/YouCompleteMe

git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑.vimrc文件，输入一下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin &#39;gmarik/Vundle.vim&#39;
call vundle#end()
filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用vim打开，后输入 :PluginInstall
完成后在 &lt;code&gt;Plugin ‘gmarik/Vundle.vim&lt;/code&gt;的下一行输入 &lt;code&gt;Plugin‘Valloric/YouCompleteMe&lt;/code&gt;，保持后退出。
然后执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/.vim/bundle/YouCompleteMe
./install.py --gocode-completer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要支持C类的补全，用下面的命令。
&lt;code&gt;./install.py --clang-completer&lt;/code&gt;
.vimrc的设置请参考官方文档。&lt;/p&gt;

&lt;h5 id=&#34;然后-安装vim-go插件&#34;&gt;然后，安装vim-go插件&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Plugin &#39;fatih/vim-go&#39;&lt;/code&gt;,然后PluginInstall.
然后安装工具包的依赖
:GoInstallBinaries的执行是交互式的，你需要回车确认。
但是不幸的是，在安装时由于万里长城，一些包下不下来，只好一个一个git clone，然后go install.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim ~/.vim/bundle/vim-go/plugin/go.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到所有依赖包了，接下来就是把所有被墙的包git+go install。&lt;/p&gt;

&lt;h5 id=&#34;vim-go默认是用ultisnips引擎插件-但这个插件需要单独安装&#34;&gt;Vim-go默认是用ultisnips引擎插件，但这个插件需要单独安装。&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;SirVer/ultisnips&#39;
Plugin &#39;honza/vim-snippets&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方说这个插件和YCM冲突，所以在.vimrc里面设置一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot; YCM settings
let g:ycm_key_list_select_completion = [&#39;&#39;, &#39;&#39;]
let g:ycm_key_list_previous_completion = [&#39;&#39;]
let g:ycm_key_invoke_completion = &#39;&amp;lt;C-Space&amp;gt;&#39;

&amp;quot; UltiSnips setting
let g:UltiSnipsExpandTrigger=&amp;quot;&amp;lt;tab&amp;gt;&amp;quot;
let g:UltiSnipsJumpForwardTrigger=&amp;quot;&amp;lt;c-b&amp;gt;&amp;quot;
let g:UltiSnipsJumpBackwardTrigger=&amp;quot;&amp;lt;c-z&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样让YCM通过回车和向下的箭头来做list item正向选择，通过向上箭头做反向选择。通过ctrl+space来原地触发补齐提示。&lt;/p&gt;

&lt;p&gt;其他个性化配置详见官方文档。&lt;/p&gt;

&lt;p&gt;Reference:
&amp;gt; &lt;a href=&#34;https://blog.csdn.net/nzyalj/article/details/75331822&#34;&gt;Centos7安装vim8.0 + YouCompleteMe&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://www.cppblog.com/lizao2/archive/2017/05/08/214916.html&#34;&gt;centos安装youcompleteme及简单使用&lt;/a&gt;
&amp;gt; &lt;a href=&#34;https://tonybai.com/2014/11/07/golang-development-environment-for-vim/&#34;&gt;Golang开发环境搭建-Vim篇&lt;/a&gt;
&amp;gt; &lt;a href=&#34;http://vimzijun.net/2016/10/30/ultisnip/&#34;&gt;vim 入坑指南（六）插件 UltiSnips&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个遍历目录的小程序</title>
      <link>https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 05 Jul 2018 08:19:34 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

func main() {
	folder := &amp;quot;.&amp;quot;
	listFile(folder)
}

func listFile(folder string) {
	files, _ := ioutil.ReadDir(folder) //specify the current dir
	for _, file := range files {
		if file.IsDir() {
			listFile(folder + &amp;quot;/&amp;quot; + file.Name())
		} else {
			fmt.Println(folder + &amp;quot;/&amp;quot; + file.Name())
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归打印当前目录下所有文件名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>包含nil指针的接口和nil接口</title>
      <link>https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 04 Jun 2018 21:26:20 +0800</pubDate>
      <guid>https://arbusz.github.io/post/%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8Cnil%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h5 id=&#34;今天看了一段代码-对运行结果十分迷惑-就研究了一番&#34;&gt;今天看了一段代码，对运行结果十分迷惑，就研究了一番。&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)
type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
    var stu *Student
    return stu
}

func main() m{

    if live() == nil {
        fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
    } else {
        fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BBBBBBB &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会出现这样的结果，于是开始调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type People interface {
	Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
	var stu *Student
	return stu
}

func printDynamicType(any interface{}) {
	fmt.Printf(&amp;quot;%T\n&amp;quot;, any)
}

func main() {
	var a = live()
	printDynamicType(a)
	if live() == nil {
		fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
	} else {
		fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
	}

	var s *Student
	fmt.Println(s == nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*main.Student
BBBBBBB &amp;lt;nil&amp;gt;
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来将*Student类型的返回值赋值给People时，接口的类型被赋值为Student类型的指针，而类型描述符被赋值为nil。而一个接口为nil的充要条件为接口的运行时类型为nil，并且接口的运行时值为nil。
如果想运行出现之前以为的运行结果，只需把Show方法和live函数里的变量改成非指针类型即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type People interface {
	Show()
}

type Student struct{}

func (stu Student) Show() {

}

func live() People {
	var stu Student
	return stu
}

func printDynamicType(any interface{}) {
	fmt.Printf(&amp;quot;%T\n&amp;quot;, any)
}

func main() {
	var a = live()
	printDynamicType(a)
	if live() == nil {
		fmt.Println(&amp;quot;AAAAAAA&amp;quot;, live())
	} else {
		fmt.Println(&amp;quot;BBBBBBB&amp;quot;, live())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.Student
BBBBBBB {}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－函数</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 20 May 2018 19:59:36 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;关键字&lt;code&gt;func&lt;/code&gt;用于定义函数。
- 无须前置声明。
- 不支持命名嵌套类型（nested）。
- 不支持同名参数重载（overload）。
- 不支持默认参数。
- 支持不定长变参。
- 支持多返回值。
- 支持命名返回值。
- 支持命名函数和闭包。
函数属于第一类对象，具备相同签名的函数视作同一类型。
&amp;gt; 第一类对象指可在运行期间创建，可做函数参数或返回值，可存入变量的实体。
函数只能判断是否为nil,不支持其他比较。
从函数返回局部变量指针是安全的，编译器会通过逃逸分析来决定是否在堆上分配内存。&lt;/p&gt;

&lt;p&gt;##参数
函数调用时，必须按照签名顺序传参，以&lt;code&gt;_&lt;/code&gt;命名的参数也不能省略。
在参数列表里，相邻的同类型参数可以合并。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x,y int,s string,_ bool) *int{
	return nil
}

func main(){
	test(1,2,&amp;quot;abc&amp;quot;)//error:not enough arguments in call to test
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;形参是指函数定义中的参数，实参则是函数调用时所传递的参数。形参类似函数局部变量，而实参则是函数外部对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝给形参内存。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x *int) {
	fmt.Printf(&amp;quot;pointer: %p,target: %v\n&amp;quot;, &amp;amp;x, x) //输出形参x的地址
}

func main() {
	a := 100
	p := &amp;amp;a
	fmt.Printf(&amp;quot;pointer: %p,target: %v\n&amp;quot;, &amp;amp;p, p) //输出实参p的地址

	test(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pointer: 0xc04206a018,target: 0xc04204c080
pointer: 0xc04206a028,target: 0xc04204c080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从输出结果来看，尽管形参和实参都指向同一目标，但是指针传递依然被复制。所以可以认为值传递和指针传递都是一种值拷贝传递。
如果函数参数过多，可以将其重构为一个结构体，也算变相实现可选参数和命名的功能。&lt;/p&gt;

&lt;h3 id=&#34;变参&#34;&gt;变参&lt;/h3&gt;

&lt;p&gt;变参本质上是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(s string, a ...int) {
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, a, a)
}

func main() {
	test(&amp;quot;abc&amp;quot;, 1, 2, 3, 4)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[]int, [1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切片作为变参时，必须进行展开操作。如果是数组，先将其转换为切片。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(a ...int) {
	fmt.Println(a)
}

func main() {
	a := [3]int{10, 20, 30}//a是数组
	test(a[:]...)//将数组转换为slice后展开
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(a ...int) {
	fmt.Println(a)
}

func main() {
	a := []int{10, 20, 30}//a是切片
	test(a...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为变参是切片，所以参数复制的只是切片自身，并不包括底层数组。&lt;/p&gt;

&lt;h2 id=&#34;返回值&#34;&gt;返回值&lt;/h2&gt;

&lt;p&gt;有返回值的额函数，必须有明确的&lt;code&gt;return&lt;/code&gt;语句，除非有&lt;code&gt;panic&lt;/code&gt;或者是无&lt;code&gt;break&lt;/code&gt;的死循环。
错误写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x int) int {
	if x&amp;gt;0{
		return 1
	} else if x&amp;lt;0{
		return -1
	}
	//error:missing return at the end of function
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x int) int {
	var a int
	if x &amp;gt; 0 {
		a = 1
	} else if x &amp;lt; 0 {
		a = -1
	}
	return a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数支持多返回值，例如常见的&lt;code&gt;error&lt;/code&gt;模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func div(x, y int) (int, error){
	if y==0{
		return 0,errors.New(&amp;quot;division by zero&amp;quot;)
	}	else {
		return x/y,nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命名返回值&#34;&gt;命名返回值&lt;/h3&gt;

&lt;p&gt;命名返回值和命名参数一样，也可以作为局部变量来使用，最后由&lt;code&gt;return&lt;/code&gt;隐式返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func div(x, y int) (z int, err error) {
	if y == 0 {
		err = errors.New(&amp;quot;division by zero&amp;quot;)
	} else {
		z = x / y
		err = nil
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数返回时，需要对所有命名值全部返回。
##匿名函数
匿名函数是没有定义名字符号的函数。
匿名函数可以直接调用，保存到变量，作为参数或返回值。
直接使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	func (s string) {
		println(s)
	} (&amp;quot;hello world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋值给变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	add := func (x, y int) int {
		return x+y
	}
	println(add(1,2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(f func()){
	f()
}

func main(){
	test(func() {
		println(&amp;quot;hello world&amp;quot;)
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() func(int,int) int {
	return func (x,y int) int {
		return x+y
	}
}

func main() {
	add := test()
	println(add(1,2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通函数和匿名函数都可作为结构体字段，或经通道传递。&lt;/p&gt;

&lt;h3 id=&#34;闭包&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;闭包是函数和引用环境的组合体。
闭包直接引用原环境变量。
闭包延迟求值的特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() []func() {
	var s []func()

	for i:=0;i&amp;lt;2;i++{
		s = append(s, func() {
			println(&amp;amp;i,i)
		})
	}
	return s
}

func main(){
	for _,f := range test() {
		f()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xc042040000 2
0xc042040000 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为&lt;code&gt;for&lt;/code&gt;循环复用局部变量&lt;code&gt;i&lt;/code&gt;，每次添加匿名函数时引用的是同一变量。添加操作仅仅是将匿名函数放入列表，并未执行。所以执行的时候读取的是环境变量&lt;code&gt;i&lt;/code&gt;最后一次循环时的值。
解决方法是每次使用不同的环境变量或者传参复制，让各自闭包环境不同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() []func() {
	var s []func()

	for i := 0; i &amp;lt; 2; i++ {
		x := i
		s = append(s, func() {
			println(&amp;amp;x, x)
		})
	}
	return s
}

func main() {
	for _, f := range test() {
		f()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xc042008038 0
0xc042008040 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;延迟调用&#34;&gt;延迟调用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;向当前函数注册，等当前函数结束前才被执行。延迟调用常用于资源释放，解除锁定，以及错误处理等操作。
多个&lt;code&gt;defer&lt;/code&gt;按照FILO。
&lt;code&gt;return&lt;/code&gt;和&lt;code&gt;panic&lt;/code&gt;都会终止当前函数，引发&lt;code&gt;defer&lt;/code&gt;。&lt;code&gt;return&lt;/code&gt;执行前会先更新返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() (z int) {
	defer func() {
		println(&amp;quot;defer:&amp;quot;,z)
		z+=100//修改命名返回值
	}()
	return 100//实际执行次序 z=100,call defer return z
}

func main(){
	println(&amp;quot;test:&amp;quot;,test())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;

&lt;p&gt;延迟调用花费代价很大，此过程包括注册、调用等操作，还有额外的缓存开销。所以性能要求高压力大的算法，应避免使用延迟调用。&lt;/p&gt;

&lt;h2 id=&#34;错误处理&#34;&gt;错误处理&lt;/h2&gt;

&lt;h3 id=&#34;error&#34;&gt;error&lt;/h3&gt;

&lt;p&gt;官方推荐做法是返回&lt;code&gt;error&lt;/code&gt;状态。
标准库将&lt;code&gt;error&lt;/code&gt;定义为接口类型，以便实现自定义错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误变量通常以&lt;code&gt;err&lt;/code&gt;作为前缀，且字符串内容全部小写，没有结束标点，以便嵌入到其他格式化字符串中输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var errDivByZero = errors.New(&amp;quot;division by zero&amp;quot;)

func div(x, y int) (int, error) {
	if y == 0 {
		return 0, errDivByZero
	}
	return x / y, nil
}
func main() {
	z, err := div(5, 0)
	if err == errDivByZero {
		log.Fatalln(err)
	}
	println(z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某些时候需要自定义错误类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DivErr struct {
	x, y int
}

func (DivErr) Error() string {
	return &amp;quot;division by zero&amp;quot;
}

func div(x, y int) (int, error) {
	if y == 0 {
		return 0, DivErr{x, y}
	}
	return x / y, nil
}

func main() {
	z, err := div(5, 0)
	if err != nil {
		switch e := err.(type) {
		case DivErr:
			fmt.Println(e, e.x, e.y)
		default:
			fmt.Println(e)
		}
		log.Fatalln(err)
	}
	println(z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;panic-recover&#34;&gt;panic,recover&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func panic(v interface{})
func recover() interface{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;panic/recover&lt;/code&gt;在使用上更接近&lt;code&gt;try/catch&lt;/code&gt;结构化异常。他们是内置函数而非语句。&lt;code&gt;panic&lt;/code&gt;会立即中断当前 函数流程，执行延迟调用。而在延迟调用中，&lt;code&gt;recover&lt;/code&gt;可捕获并返回&lt;code&gt;panic&lt;/code&gt;提交的错误对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	defer func() {
		if err := recover(); err != nil {//捕获错误
			log.Fatalln(err)
		}
	}()
	panic(&amp;quot;i am dead&amp;quot;)//引发错误
	panic(&amp;quot;exit&amp;quot;)//不会执行
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是否执行&lt;code&gt;recover&lt;/code&gt;，所有延迟调用都会被执行。但是中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() {
	defer println(&amp;quot;test.1&amp;quot;)
	defer println(&amp;quot;test.2&amp;quot;)
	panic(&amp;quot;i am dead&amp;quot;)
}
func main() {
	defer func() {
		log.Println(recover())
	}()
	test()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test.2
test.1
i am dead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连续调用&lt;code&gt;panic&lt;/code&gt;，仅最后一个会被&lt;code&gt;recover&lt;/code&gt;捕获。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	defer func() {
		for {
			if err := recover(); err != nil {
				log.Println(err)
			} else {
				log.Fatalln(&amp;quot;fatal&amp;quot;)
			}
		}
	}()
	defer func() {
		panic(&amp;quot;you are dead&amp;quot;) // 类似重新抛出异常（ rethrow）
	}() // 可先 recover捕获，包装后重新抛出
	panic(&amp;quot;i am dead&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;you are dead
fatal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;recover&lt;/code&gt;必须在延迟调用函数中才执行能正常工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func catch() {
	log.Println(&amp;quot;catch &amp;quot;,recover())
}

func main(){
	defer log.Println(recover())
	defer catch()
	panic(&amp;quot;i am &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;catch i am
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func catch() {
	log.Println(&amp;quot;catch &amp;quot;, recover())
}

func main() {
	defer catch()
	defer log.Println(recover())
	panic(&amp;quot;i am &amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nil
catch i am
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－表达式</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 20 May 2018 19:45:45 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;表达式&#34;&gt;表达式&lt;/h1&gt;

&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;

&lt;p&gt;指针运算符为左值时，可以更新目标状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main(){
	x:=10

	var p *int = &amp;amp;x
	println(&amp;amp;x,x)
	println(p,*p)
	*p += 20
	println(p,*p)
	println(&amp;amp;x,x)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0xc04202ff60 10
0xc04202ff60 10
0xc04202ff60 30
0xc04202ff60 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并非所有对象都能进行取地址操作
指针类型不能做加减运算和类型转换&lt;/p&gt;

&lt;h2 id=&#34;复合类型变量的初始化&#34;&gt;复合类型变量的初始化&lt;/h2&gt;

&lt;p&gt;一些语法限制
- 初始化表达式必须含类型标签
- 左花括号必须在类型尾部，不能另起一行
- 多个成员的初始值以逗号分开
- 允许多行，但每行必须以逗号或者右花括号结束&lt;/p&gt;

&lt;h2 id=&#34;流控制&#34;&gt;流控制&lt;/h2&gt;

&lt;h5 id=&#34;if-else&#34;&gt;if&amp;hellip;else&amp;hellip;&lt;/h5&gt;

&lt;p&gt;条件表达式必须是布尔类型 ，可以省略括号
可以在条件表达式前加初始化语句，可定义块局部变量（作用域是该&lt;code&gt;if&lt;/code&gt;语句或执行 初始化函数。&lt;/p&gt;

&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;

&lt;p&gt;某条&lt;code&gt;case&lt;/code&gt;语句里有多个条件时，只要有一个命中即可匹配
如果有&lt;code&gt;default&lt;/code&gt;,在全部&lt;code&gt;case&lt;/code&gt;执行失败后才会执行&lt;code&gt;default&lt;/code&gt;语句。
不能重复出现常量&lt;code&gt;case&lt;/code&gt;条件。
相邻的空&lt;code&gt;case&lt;/code&gt;不构成多条件匹配，&lt;code&gt;case&lt;/code&gt;内容为空默认包含一个&lt;code&gt;break&lt;/code&gt;语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; switch x {
 case a:
 case b:
	 println(&amp;quot;b&amp;quot;)
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fallthrough&#34;&gt;fallthrough&lt;/h4&gt;

&lt;p&gt;如需贯通后续的&lt;code&gt;case&lt;/code&gt;,需执行&lt;code&gt;fallthrough。&lt;/code&gt;
当有&lt;code&gt;fallthrough&lt;/code&gt;时，不必匹配后续条件表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	switch x:=5;x{
	default:
		println(x)
	case 5:
		x+=10
		println(x)
		fallthrough
	case 10:
		println(x)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;15
15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fallthrough&lt;/code&gt;必须放在&lt;code&gt;case&lt;/code&gt;结尾处，可以使用&lt;code&gt;break&lt;/code&gt;阻止执行。&lt;/p&gt;

&lt;h3 id=&#34;for&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go&lt;/code&gt;语言只有一种循环，但是常见方法都能支持。
常见写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i=0;i&amp;lt;3;i++{ //初始化表达式支持函数调用或者定义局变量
}

for x&amp;lt;10{ //类似“while x&amp;lt;10{}”
}

for { //类似“while true{}”
	break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用&lt;code&gt;for...rang&lt;/code&gt;完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for i,s := range data{
		println(i,s)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许单返回值，或者使用&lt;code&gt;_&lt;/code&gt;忽略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for i := range data{
		println(i)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	data := [3]string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}
	for _,s := range data{
		println(s)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;code&gt;range&lt;/code&gt;也有个大坑，就是定义的局部变量会重复使用，即一个地址多次写值。
详见本博客博文《go语言坑之for range》。
如果&lt;code&gt;range&lt;/code&gt;的目标表达式是函数优化，也仅被执行一次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	for i,s := range data(){
		println(i,s)
	}

}
func data() []int {
	println(&amp;quot;origin data.&amp;quot;)
	return []int{10,20,30}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origin data.
0 10
1 20
2 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goto&lt;/code&gt; &lt;code&gt;continue&lt;/code&gt; &lt;code&gt;break&lt;/code&gt;略过。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言笔记－类型</title>
      <link>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 27 Mar 2018 19:24:27 +0800</pubDate>
      <guid>https://arbusz.github.io/post/go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;h4 id=&#34;简短模式&#34;&gt;简短模式：&lt;/h4&gt;

&lt;p&gt;简短模式的限制
- 定义变量，同时显式初始化
- 不能提供数据类型
- 只能用在函数内部&lt;/p&gt;

&lt;p&gt;简短模式也可以是部分退化的赋值操作，即一部分变量定义，一部分只是赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	x := 100
	println(&amp;amp;x)

	x,y := 200, &amp;quot;abc&amp;quot;
	println(x,y)

	y,z := &amp;quot;asd&amp;quot;, 100
	println(y,z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在退化赋值中，靠左变量定义和靠右变量定义都可以.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可以看出，赋值退化的前提条件是，至少有一个新变量被定义，并且必须是同一作用域&lt;/strong&gt;
退化赋值的常用场景是在接受错误类型时，我们可以重复使用err变量&lt;/p&gt;

&lt;h4 id=&#34;多变量赋值&#34;&gt;多变量赋值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
  x,y:= 1,2
  x,y:= y+2, x+3
  println(x,y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;底层过程是先算出所有右值，再进行赋值操作&lt;/p&gt;

&lt;p&gt;####　未使用错误
编译器将未使用的局部变量&lt;/p&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;p&gt;常量必须是编译期可确定的基础数字类型（字符、字符串、数字和布尔值）。
可以在函数代码块中定义常量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	const x  = &amp;quot;abc&amp;quot;
	println(x)

	{
		const x  = 100
		println(x)
		const y  = 1.1
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abc
100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在常量组中，如果不指定类型和初始化值，则与上一行非空常量右值相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	const (
		x uint16 = 120
		y
		s = &amp;quot;abc&amp;quot;
		z
		p
	)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, y, y)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, z, z)
	fmt.Printf(&amp;quot;%T, %v\n&amp;quot;, p, p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint16, 120
string, abc
string, abc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;枚举&#34;&gt;枚举&lt;/h4&gt;

&lt;p&gt;Go语言没有明确的emun类型，但是可以借助&lt;code&gt;iota&lt;/code&gt;标识符实现一组自增量来实现枚举类型。
&lt;code&gt;iota&lt;/code&gt;的自增作用范围为常量组，可在多常量定义中使用多个&lt;code&gt;iota&lt;/code&gt;。他们单独计数，只需确保组中每行常量个数相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	const (
		_, _ = iota, iota * 10
		a, b
		c, d
		e, f = 10, iota
	)
	fmt.Println(a, b)
	fmt.Println(c, d)
	fmt.Println(e, f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 10
2 20
10 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;展开&#34;&gt;展开&lt;/h4&gt;

&lt;p&gt;常量会在编译器预处理阶段直接展开，作为指令使用。数字常量不会分配存储空间，因此无法获取地址。&lt;/p&gt;

&lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;

&lt;h4 id=&#34;别名&#34;&gt;别名&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;byte alias for unit8
rune alias for int32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但相同底层结构一致不一定是别名。&lt;/p&gt;

&lt;p&gt;##　引用类型
特指&lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;这三种预定义类型。
与基本类型相比，它们拥有更复杂的存储结构，除了分配内存以外，还需初始化指针、长度、甚至哈希分布、数据队列等。&lt;/p&gt;

&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;

&lt;p&gt;强制要求显式类型转换。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>协程Coroutines</title>
      <link>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://arbusz.github.io/post/%E5%8D%8F%E7%A8%8Bcoroutines/</guid>
      <description>

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;协程的概念&#34;&gt;协程的概念&lt;/h2&gt;

&lt;p&gt;对操作系统来说，进程是最小的资源管理单元，线程是最小的执行单元。
对于进程和线程，都是有内核进行调度，有CPU时间片的概念，有多种调度算法。&lt;/p&gt;

&lt;p&gt;协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以有多个协程。
协程不是被操作系统内核所管理，而是完全在用户态执行，换句话说，协程是用户透明的。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。&lt;/p&gt;

&lt;h2 id=&#34;goroutine和协程的区别&#34;&gt;goroutine和协程的区别&lt;/h2&gt;

&lt;p&gt;本质上，goroutine就是协程。不同的是，Go在runtime、系统调用等多方面对goroutine调度进行了封装和处理。当遇到长时间执行或进行系统调用时，会主动把当前的goroutine的CPU转让出去，让其他goroutine能被调度和执行，也就是GO从语言层面支持了协程。&lt;/p&gt;

&lt;p&gt;在内存消耗方面，每个goroutine默认占用的内存远比C、Java的线程少。
在切换调度开销方面，线程涉及到模式切换（用户态与内核态）、多个寄存器刷新。goroutine只有三个寄存器的值修改（PC/SP/DX)。&lt;/p&gt;

&lt;h2 id=&#34;协程的底层实现&#34;&gt;协程的底层实现&lt;/h2&gt;

&lt;p&gt;协程是在应用层模拟线程，他避免了上下文切换的额外消耗，同时兼顾了多线程的优点，简化了高并发程序的复杂性。
实现原理与线程类似，线程a切换到线程b时，需要将线程a的相关执行进度压栈，然后线程b的执行进度出栈，进入线程b的执行序列。协程只不过是在应用层实现了这一点。
协程是基于线程的。内部实现上，维护了一组数据结构和n个线程，真正执行的还是线程。协程执行的代码被扔进一个待执行队列中，由这n个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步io函数，当这些异步函数返回busy或bloking时，golang利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。
(Go语言运行库封装了异步io，但即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用io事件驱动设计的、按照事物类型划分好合适比例的线程池，在响应时间上，协作调度是硬伤。)&lt;/p&gt;

&lt;p&gt;挖坑：goroutine的详细底层实现和应用&lt;/p&gt;应用&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
